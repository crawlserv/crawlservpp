<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>crawlserv++: crawlservpp::Module::Extractor::Config::Entries Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">crawlserv++
   &#160;<span id="projectnumber">[under development]</span>
   </div>
   <div id="projectbrief">Application for crawling and analyzing textual content of websites.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">crawlservpp::Module::Extractor::Config::Entries Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Configuration entries for extractor threads.  
 <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Module_2Extractor_2Config_8hpp_source.html">Config.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Extractor Configuration</h2></td></tr>
<tr class="memitem:aea79feab8a4902c0185dd12459db733a"><td class="memItemLeft" align="right" valign="top">std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#aea79feab8a4902c0185dd12459db733a">generalCacheSize</a> {<a class="el" href="namespacecrawlservpp_1_1Module_1_1Extractor.html#ae2fd5c01fe236338c3f66d1d241d0d05">defaultCacheSize</a>}</td></tr>
<tr class="memdesc:aea79feab8a4902c0185dd12459db733a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of URLs fetched and extracted from before saving results.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#aea79feab8a4902c0185dd12459db733a">More...</a><br /></td></tr>
<tr class="separator:aea79feab8a4902c0185dd12459db733a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ed9a229a1b3b0897a567aa9768fb67"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a77ed9a229a1b3b0897a567aa9768fb67">generalExtractCustom</a> {false}</td></tr>
<tr class="memdesc:a77ed9a229a1b3b0897a567aa9768fb67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether to include custom URLs when extracting.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a77ed9a229a1b3b0897a567aa9768fb67">More...</a><br /></td></tr>
<tr class="separator:a77ed9a229a1b3b0897a567aa9768fb67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a287b212f48013a10f484dc5ee3d1ef8a"><td class="memItemLeft" align="right" valign="top">std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a287b212f48013a10f484dc5ee3d1ef8a">generalLock</a> {<a class="el" href="namespacecrawlservpp_1_1Module_1_1Extractor.html#a28a5d5a844057ab9bb7758c5153f8db5">defaultLockS</a>}</td></tr>
<tr class="memdesc:a287b212f48013a10f484dc5ee3d1ef8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">URL locking time, in seconds.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a287b212f48013a10f484dc5ee3d1ef8a">More...</a><br /></td></tr>
<tr class="separator:a287b212f48013a10f484dc5ee3d1ef8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9398ba1101d2565b864676168801e8ce"><td class="memItemLeft" align="right" valign="top">std::uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a9398ba1101d2565b864676168801e8ce">generalLogging</a> {<a class="el" href="namespacecrawlservpp_1_1Module_1_1Extractor.html#a5ebd89ee46e6b9ee7acbf54d20e3112d">generalLoggingDefault</a>}</td></tr>
<tr class="memdesc:a9398ba1101d2565b864676168801e8ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Level of logging activity.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a9398ba1101d2565b864676168801e8ce">More...</a><br /></td></tr>
<tr class="separator:a9398ba1101d2565b864676168801e8ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad813fd72c49e9a51e06b7f9a381d8613"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ad813fd72c49e9a51e06b7f9a381d8613">generalMinimizeMemory</a> {false}</td></tr>
<tr class="memdesc:ad813fd72c49e9a51e06b7f9a381d8613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether to free small amounts of unused memory more often, at the expense of performance.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ad813fd72c49e9a51e06b7f9a381d8613">More...</a><br /></td></tr>
<tr class="separator:ad813fd72c49e9a51e06b7f9a381d8613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef299b6cc113d013577f5fb7ddeb7e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#afef299b6cc113d013577f5fb7ddeb7e9">generalReExtract</a> {false}</td></tr>
<tr class="memdesc:afef299b6cc113d013577f5fb7ddeb7e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether to re-extract data from already processed URLs.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#afef299b6cc113d013577f5fb7ddeb7e9">More...</a><br /></td></tr>
<tr class="separator:afef299b6cc113d013577f5fb7ddeb7e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad18b6e6d5a54f9a521fb74891d952cd1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ad18b6e6d5a54f9a521fb74891d952cd1">generalTargetTable</a></td></tr>
<tr class="memdesc:ad18b6e6d5a54f9a521fb74891d952cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of table to save extracted data to.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ad18b6e6d5a54f9a521fb74891d952cd1">More...</a><br /></td></tr>
<tr class="separator:ad18b6e6d5a54f9a521fb74891d952cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af58f723f64291bb302f57c1c745623e8"><td class="memItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#af58f723f64291bb302f57c1c745623e8">generalReTries</a> {<a class="el" href="namespacecrawlservpp_1_1Module_1_1Extractor.html#aeb45747890d65c1325db2c3bef01531e">defaultReTries</a>}</td></tr>
<tr class="memdesc:af58f723f64291bb302f57c1c745623e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of re-tries on connection errors.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#af58f723f64291bb302f57c1c745623e8">More...</a><br /></td></tr>
<tr class="separator:af58f723f64291bb302f57c1c745623e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6251a2518f216fa11c3cf8d766a240d8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::uint32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a6251a2518f216fa11c3cf8d766a240d8">generalRetryHttp</a></td></tr>
<tr class="memdesc:a6251a2518f216fa11c3cf8d766a240d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">HTTP errors that will be handled like connection errors.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a6251a2518f216fa11c3cf8d766a240d8">More...</a><br /></td></tr>
<tr class="separator:a6251a2518f216fa11c3cf8d766a240d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a488548e0ae622c1c264f8d4a8ee32b6f"><td class="memItemLeft" align="right" valign="top">std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a488548e0ae622c1c264f8d4a8ee32b6f">generalSleepError</a> {<a class="el" href="namespacecrawlservpp_1_1Module_1_1Extractor.html#a8838401e308bcfe8410d3bdaf4197363">defaultSleepErrorMs</a>}</td></tr>
<tr class="memdesc:a488548e0ae622c1c264f8d4a8ee32b6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sleeping time (in ms) on connection errors, in milliseconds.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a488548e0ae622c1c264f8d4a8ee32b6f">More...</a><br /></td></tr>
<tr class="separator:a488548e0ae622c1c264f8d4a8ee32b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b87413044483a01fb42190f8aa12c89"><td class="memItemLeft" align="right" valign="top">std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a1b87413044483a01fb42190f8aa12c89">generalSleepHttp</a> {<a class="el" href="namespacecrawlservpp_1_1Module_1_1Extractor.html#ad14b26822b0ca616dd61688368199a9f">defaultSleepHttpMs</a>}</td></tr>
<tr class="memdesc:a1b87413044483a01fb42190f8aa12c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time that will be waited between HTTP requests, in milliseconds.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a1b87413044483a01fb42190f8aa12c89">More...</a><br /></td></tr>
<tr class="separator:a1b87413044483a01fb42190f8aa12c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99cc25e6b3998f8032a3215f1581359"><td class="memItemLeft" align="right" valign="top">std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ac99cc25e6b3998f8032a3215f1581359">generalSleepIdle</a> {<a class="el" href="namespacecrawlservpp_1_1Module_1_1Extractor.html#a6a68497febc6364608762a97cff453bb">defaultSleepIdleMs</a>}</td></tr>
<tr class="memdesc:ac99cc25e6b3998f8032a3215f1581359"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time to wait before checking for new URLs when all URLs have been processed, in milliseconds.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ac99cc25e6b3998f8032a3215f1581359">More...</a><br /></td></tr>
<tr class="separator:ac99cc25e6b3998f8032a3215f1581359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d350ff1f657de4311c74aa42265cfb"><td class="memItemLeft" align="right" valign="top">std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a01d350ff1f657de4311c74aa42265cfb">generalSleepMySql</a> {<a class="el" href="namespacecrawlservpp_1_1Module_1_1Extractor.html#a826ccf320a90715d86f08b4f98b64e02">defaultSleepMySqlS</a>}</td></tr>
<tr class="memdesc:a01d350ff1f657de4311c74aa42265cfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time to wait before last try to re-connect to mySQL server, in seconds.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a01d350ff1f657de4311c74aa42265cfb">More...</a><br /></td></tr>
<tr class="separator:a01d350ff1f657de4311c74aa42265cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6abe78475aa8df84f87bf5d8be03889"><td class="memItemLeft" align="right" valign="top">std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ab6abe78475aa8df84f87bf5d8be03889">generalTidyErrors</a> {0}</td></tr>
<tr class="memdesc:ab6abe78475aa8df84f87bf5d8be03889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of <code>tidyhtml</code> errors to write to the log.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ab6abe78475aa8df84f87bf5d8be03889">More...</a><br /></td></tr>
<tr class="separator:ab6abe78475aa8df84f87bf5d8be03889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474212c2a7389400665dff626e06037a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a474212c2a7389400665dff626e06037a">generalTidyWarnings</a> {false}</td></tr>
<tr class="memdesc:a474212c2a7389400665dff626e06037a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether to write <code>tidyhtml</code> warnings to the log.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a474212c2a7389400665dff626e06037a">More...</a><br /></td></tr>
<tr class="separator:a474212c2a7389400665dff626e06037a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6aaa53514ae289e6c1a7ca03ea95c38"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ae6aaa53514ae289e6c1a7ca03ea95c38">generalTiming</a> {false}</td></tr>
<tr class="memdesc:ae6aaa53514ae289e6c1a7ca03ea95c38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether to calculate timing statistics for the extractor.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ae6aaa53514ae289e6c1a7ca03ea95c38">More...</a><br /></td></tr>
<tr class="separator:ae6aaa53514ae289e6c1a7ca03ea95c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Variables</h2></td></tr>
<tr class="memitem:a87bdc42f81d342fe0ba7d398220a63ca"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a87bdc42f81d342fe0ba7d398220a63ca">variablesAlias</a></td></tr>
<tr class="memdesc:a87bdc42f81d342fe0ba7d398220a63ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for the variable with same array index.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a87bdc42f81d342fe0ba7d398220a63ca">More...</a><br /></td></tr>
<tr class="separator:a87bdc42f81d342fe0ba7d398220a63ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3f1d2c72cc2bf0e585ea51c50dedaf"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a9a3f1d2c72cc2bf0e585ea51c50dedaf">variablesAliasAdd</a></td></tr>
<tr class="memdesc:a9a3f1d2c72cc2bf0e585ea51c50dedaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value to add to the variable alias with the same array index.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a9a3f1d2c72cc2bf0e585ea51c50dedaf">More...</a><br /></td></tr>
<tr class="separator:a9a3f1d2c72cc2bf0e585ea51c50dedaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a496079302ceff8f225d3dd473aa83f16"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a496079302ceff8f225d3dd473aa83f16">variablesDateTimeFormat</a></td></tr>
<tr class="memdesc:a496079302ceff8f225d3dd473aa83f16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Date/time format to be used for the variable with the same array index.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a496079302ceff8f225d3dd473aa83f16">More...</a><br /></td></tr>
<tr class="separator:a496079302ceff8f225d3dd473aa83f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548bdb7e71090d88501c25ed4df6d3f4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a548bdb7e71090d88501c25ed4df6d3f4">variablesDateTimeLocale</a></td></tr>
<tr class="memdesc:a548bdb7e71090d88501c25ed4df6d3f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Date/time locale to be used for the variable with the same array index.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a548bdb7e71090d88501c25ed4df6d3f4">More...</a><br /></td></tr>
<tr class="separator:a548bdb7e71090d88501c25ed4df6d3f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537337679b5a29b1f5eee89db7a09450"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a537337679b5a29b1f5eee89db7a09450">variablesName</a></td></tr>
<tr class="memdesc:a537337679b5a29b1f5eee89db7a09450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable names.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a537337679b5a29b1f5eee89db7a09450">More...</a><br /></td></tr>
<tr class="separator:a537337679b5a29b1f5eee89db7a09450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ebf05ef3503f82773fd204b2471df5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a29ebf05ef3503f82773fd204b2471df5">variablesParsedColumn</a></td></tr>
<tr class="memdesc:a29ebf05ef3503f82773fd204b2471df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parsed column for the value of the variable with the same array index.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a29ebf05ef3503f82773fd204b2471df5">More...</a><br /></td></tr>
<tr class="separator:a29ebf05ef3503f82773fd204b2471df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41149ab3a45aa1310f5aeeb6c4a9bb97"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a41149ab3a45aa1310f5aeeb6c4a9bb97">variablesParsedTable</a></td></tr>
<tr class="memdesc:a41149ab3a45aa1310f5aeeb6c4a9bb97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of the table containing the parsed data for the variable with the same array index.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a41149ab3a45aa1310f5aeeb6c4a9bb97">More...</a><br /></td></tr>
<tr class="separator:a41149ab3a45aa1310f5aeeb6c4a9bb97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d5e42c084c36b56f6a107edff41c6c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ab1d5e42c084c36b56f6a107edff41c6c">variablesQuery</a></td></tr>
<tr class="memdesc:ab1d5e42c084c36b56f6a107edff41c6c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacecrawlservpp_1_1Query.html" title="Namespace for classes handling queries.">Query</a> on the content or URL for the variable with the same array index.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ab1d5e42c084c36b56f6a107edff41c6c">More...</a><br /></td></tr>
<tr class="separator:ab1d5e42c084c36b56f6a107edff41c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f4a6e514b4f8cfabd47c064333ff69"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ad6f4a6e514b4f8cfabd47c064333ff69">variablesSource</a></td></tr>
<tr class="memdesc:ad6f4a6e514b4f8cfabd47c064333ff69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Source of the variable with the same array index.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ad6f4a6e514b4f8cfabd47c064333ff69">More...</a><br /></td></tr>
<tr class="separator:ad6f4a6e514b4f8cfabd47c064333ff69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5fd3296338244f27c7e936937c842a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a5c5fd3296338244f27c7e936937c842a">variablesTokens</a></td></tr>
<tr class="memdesc:a5c5fd3296338244f27c7e936937c842a"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of token variables.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a5c5fd3296338244f27c7e936937c842a">More...</a><br /></td></tr>
<tr class="separator:a5c5fd3296338244f27c7e936937c842a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97fd461ee8800b015e255f34c17f8d19"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a97fd461ee8800b015e255f34c17f8d19">variablesTokensCookies</a></td></tr>
<tr class="memdesc:a97fd461ee8800b015e255f34c17f8d19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom HTTP <code>Cookie</code> header for the token variable with the same array index.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a97fd461ee8800b015e255f34c17f8d19">More...</a><br /></td></tr>
<tr class="separator:a97fd461ee8800b015e255f34c17f8d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a010c8c080034acab14341d91108d5124"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a010c8c080034acab14341d91108d5124">variablesTokensQuery</a></td></tr>
<tr class="memdesc:a010c8c080034acab14341d91108d5124"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacecrawlservpp_1_1Query.html" title="Namespace for classes handling queries.">Query</a> to extract token variable with the same array index.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a010c8c080034acab14341d91108d5124">More...</a><br /></td></tr>
<tr class="separator:a010c8c080034acab14341d91108d5124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a172e4f528d26d7705ad05c0bb8158528"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a172e4f528d26d7705ad05c0bb8158528">variablesTokensSource</a></td></tr>
<tr class="memdesc:a172e4f528d26d7705ad05c0bb8158528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Source URL for the token variable with the same array index.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a172e4f528d26d7705ad05c0bb8158528">More...</a><br /></td></tr>
<tr class="separator:a172e4f528d26d7705ad05c0bb8158528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a1a3d9b38b668ae03781f1cb3e6b9ff"><td class="memItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a1a1a3d9b38b668ae03781f1cb3e6b9ff">variablesTokensUsePost</a></td></tr>
<tr class="memdesc:a1a1a3d9b38b668ae03781f1cb3e6b9ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether to use HTTP POST instead of GET for the token variable with the same array index.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a1a1a3d9b38b668ae03781f1cb3e6b9ff">More...</a><br /></td></tr>
<tr class="separator:a1a1a3d9b38b668ae03781f1cb3e6b9ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15120e18cae30bb900cbc9c057c20d5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ae15120e18cae30bb900cbc9c057c20d5">variablesTokenHeaders</a></td></tr>
<tr class="memdesc:ae15120e18cae30bb900cbc9c057c20d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom HTTP headers to be used for ALL token variables.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ae15120e18cae30bb900cbc9c057c20d5">More...</a><br /></td></tr>
<tr class="separator:ae15120e18cae30bb900cbc9c057c20d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Paging</h2></td></tr>
<tr class="memitem:a828ba9f0da22b5e2cd1398fae8bc6337"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a828ba9f0da22b5e2cd1398fae8bc6337">pagingAlias</a></td></tr>
<tr class="memdesc:a828ba9f0da22b5e2cd1398fae8bc6337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for the paging variable.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a828ba9f0da22b5e2cd1398fae8bc6337">More...</a><br /></td></tr>
<tr class="separator:a828ba9f0da22b5e2cd1398fae8bc6337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d6dd4b76e1a3894c33af1d0a758ecf2"><td class="memItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a6d6dd4b76e1a3894c33af1d0a758ecf2">pagingAliasAdd</a> {0}</td></tr>
<tr class="memdesc:a6d6dd4b76e1a3894c33af1d0a758ecf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value to add to the alias for the paging variable.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a6d6dd4b76e1a3894c33af1d0a758ecf2">More...</a><br /></td></tr>
<tr class="separator:a6d6dd4b76e1a3894c33af1d0a758ecf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c27f27ac6c4455ef9d6fdfab9e5e3ef"><td class="memItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a1c27f27ac6c4455ef9d6fdfab9e5e3ef">pagingFirst</a> {0}</td></tr>
<tr class="memdesc:a1c27f27ac6c4455ef9d6fdfab9e5e3ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of the first page.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a1c27f27ac6c4455ef9d6fdfab9e5e3ef">More...</a><br /></td></tr>
<tr class="separator:a1c27f27ac6c4455ef9d6fdfab9e5e3ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a0097a5ea5e466c52a703a773f691b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#af4a0097a5ea5e466c52a703a773f691b">pagingFirstString</a></td></tr>
<tr class="memdesc:af4a0097a5ea5e466c52a703a773f691b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of the first page.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#af4a0097a5ea5e466c52a703a773f691b">More...</a><br /></td></tr>
<tr class="separator:af4a0097a5ea5e466c52a703a773f691b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1631e2b4e06995f2464c0645e7a1304"><td class="memItemLeft" align="right" valign="top">std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ad1631e2b4e06995f2464c0645e7a1304">pagingIsNextFrom</a> {0}</td></tr>
<tr class="memdesc:ad1631e2b4e06995f2464c0645e7a1304"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacecrawlservpp_1_1Query.html" title="Namespace for classes handling queries.">Query</a> on page content to determine whether there is another page.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ad1631e2b4e06995f2464c0645e7a1304">More...</a><br /></td></tr>
<tr class="separator:ad1631e2b4e06995f2464c0645e7a1304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae840393dfe0c185cee60a69f509b485d"><td class="memItemLeft" align="right" valign="top">std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ae840393dfe0c185cee60a69f509b485d">pagingNextFrom</a> {0}</td></tr>
<tr class="memdesc:ae840393dfe0c185cee60a69f509b485d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacecrawlservpp_1_1Query.html" title="Namespace for classes handling queries.">Query</a> on page content to find the number(s) or name(s) of additional pages.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ae840393dfe0c185cee60a69f509b485d">More...</a><br /></td></tr>
<tr class="separator:ae840393dfe0c185cee60a69f509b485d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a539b1476f7d0f1714fa2003bbff92944"><td class="memItemLeft" align="right" valign="top">std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a539b1476f7d0f1714fa2003bbff92944">pagingNumberFrom</a> {0}</td></tr>
<tr class="memdesc:a539b1476f7d0f1714fa2003bbff92944"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacecrawlservpp_1_1Query.html" title="Namespace for classes handling queries.">Query</a> to determine the total number of pages from the content of the first page.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a539b1476f7d0f1714fa2003bbff92944">More...</a><br /></td></tr>
<tr class="separator:a539b1476f7d0f1714fa2003bbff92944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a8a7a5da10b6e8621e48730c73a870"><td class="memItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a12a8a7a5da10b6e8621e48730c73a870">pagingStep</a> {1}</td></tr>
<tr class="memdesc:a12a8a7a5da10b6e8621e48730c73a870"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number to add to page variable for retrieving the next page, if a page number is used.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a12a8a7a5da10b6e8621e48730c73a870">More...</a><br /></td></tr>
<tr class="separator:a12a8a7a5da10b6e8621e48730c73a870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cbac30763236e922f15e280e6edcec1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a8cbac30763236e922f15e280e6edcec1">pagingVariable</a> {<a class="el" href="namespacecrawlservpp_1_1Module_1_1Extractor.html#af68631bc4caf086304cea289ce1e36ae">defaultPagingVariable</a>}</td></tr>
<tr class="memdesc:a8cbac30763236e922f15e280e6edcec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of the paging variable.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a8cbac30763236e922f15e280e6edcec1">More...</a><br /></td></tr>
<tr class="separator:a8cbac30763236e922f15e280e6edcec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Source</h2></td></tr>
<tr class="memitem:a6dfc4b1da76d80d3e1cb92651a96451d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a6dfc4b1da76d80d3e1cb92651a96451d">sourceCookies</a></td></tr>
<tr class="memdesc:a6dfc4b1da76d80d3e1cb92651a96451d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom HTTP <code>Cookie</code> header used when retrieving data.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a6dfc4b1da76d80d3e1cb92651a96451d">More...</a><br /></td></tr>
<tr class="separator:a6dfc4b1da76d80d3e1cb92651a96451d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d870bc739d1a48e19efd0f76e6d5b3f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a2d870bc739d1a48e19efd0f76e6d5b3f">sourceHeaders</a></td></tr>
<tr class="memdesc:a2d870bc739d1a48e19efd0f76e6d5b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom HTTP headers used when retrieving data.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a2d870bc739d1a48e19efd0f76e6d5b3f">More...</a><br /></td></tr>
<tr class="separator:a2d870bc739d1a48e19efd0f76e6d5b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b9f6649781af69b8af2a895b914a031"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a4b9f6649781af69b8af2a895b914a031">sourceUrl</a></td></tr>
<tr class="memdesc:a4b9f6649781af69b8af2a895b914a031"><td class="mdescLeft">&#160;</td><td class="mdescRight">URL to retrieve data from.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a4b9f6649781af69b8af2a895b914a031">More...</a><br /></td></tr>
<tr class="separator:a4b9f6649781af69b8af2a895b914a031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab379e24c181fb3f796fbda4d5c4e5f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#adab379e24c181fb3f796fbda4d5c4e5f">sourceUrlFirst</a></td></tr>
<tr class="memdesc:adab379e24c181fb3f796fbda4d5c4e5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">URL of the first page to retrieve data from.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#adab379e24c181fb3f796fbda4d5c4e5f">More...</a><br /></td></tr>
<tr class="separator:adab379e24c181fb3f796fbda4d5c4e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d37f47f189161b56bcc838ac0f88f5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ae9d37f47f189161b56bcc838ac0f88f5">sourceUsePost</a> {false}</td></tr>
<tr class="memdesc:ae9d37f47f189161b56bcc838ac0f88f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether to use HTTP POST instead of HTTP GET for extracting data.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ae9d37f47f189161b56bcc838ac0f88f5">More...</a><br /></td></tr>
<tr class="separator:ae9d37f47f189161b56bcc838ac0f88f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Extracting</h2></td></tr>
<tr class="memitem:a94b4fa0a7fd9a5c93804650ad132d0e3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a94b4fa0a7fd9a5c93804650ad132d0e3">extractingDatasetQueries</a></td></tr>
<tr class="memdesc:a94b4fa0a7fd9a5c93804650ad132d0e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries to extract datasets.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a94b4fa0a7fd9a5c93804650ad132d0e3">More...</a><br /></td></tr>
<tr class="separator:a94b4fa0a7fd9a5c93804650ad132d0e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4134a28dce4376e11a68517cb3395e98"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a4134a28dce4376e11a68517cb3395e98">extractingDateTimeFormats</a></td></tr>
<tr class="memdesc:a4134a28dce4376e11a68517cb3395e98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format of date/time to be extracted by the date/time query with the same array index.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a4134a28dce4376e11a68517cb3395e98">More...</a><br /></td></tr>
<tr class="separator:a4134a28dce4376e11a68517cb3395e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b6726de8d9a9070058e40c91ec29b21"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a8b6726de8d9a9070058e40c91ec29b21">extractingDateTimeLocales</a></td></tr>
<tr class="memdesc:a8b6726de8d9a9070058e40c91ec29b21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locale used by the date/time query with the same array index for extracting date and time.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a8b6726de8d9a9070058e40c91ec29b21">More...</a><br /></td></tr>
<tr class="separator:a8b6726de8d9a9070058e40c91ec29b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081b6756ae773864a600f44123bff061"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a081b6756ae773864a600f44123bff061">extractingDateTimeQueries</a></td></tr>
<tr class="memdesc:a081b6756ae773864a600f44123bff061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries used for extracting date/time from the dataset.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a081b6756ae773864a600f44123bff061">More...</a><br /></td></tr>
<tr class="separator:a081b6756ae773864a600f44123bff061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02198b039d023566f18b4bf1e8efcbd8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a02198b039d023566f18b4bf1e8efcbd8">extractingErrorFail</a></td></tr>
<tr class="memdesc:a02198b039d023566f18b4bf1e8efcbd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries to detect fatal errors in the data.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a02198b039d023566f18b4bf1e8efcbd8">More...</a><br /></td></tr>
<tr class="separator:a02198b039d023566f18b4bf1e8efcbd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676fdfe96a323f8b8355795b752e2c60"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a676fdfe96a323f8b8355795b752e2c60">extractingErrorRetry</a></td></tr>
<tr class="memdesc:a676fdfe96a323f8b8355795b752e2c60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries to detect temporary errors in the data.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a676fdfe96a323f8b8355795b752e2c60">More...</a><br /></td></tr>
<tr class="separator:a676fdfe96a323f8b8355795b752e2c60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25490b2d7bf3b42fc52f376d9b1c957c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a25490b2d7bf3b42fc52f376d9b1c957c">extractingFieldDateTimeFormats</a></td></tr>
<tr class="memdesc:a25490b2d7bf3b42fc52f376d9b1c957c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Date/time format of the field with the same array index.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a25490b2d7bf3b42fc52f376d9b1c957c">More...</a><br /></td></tr>
<tr class="separator:a25490b2d7bf3b42fc52f376d9b1c957c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad97890f7e65216346befddd270c858"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a5ad97890f7e65216346befddd270c858">extractingFieldDateTimeLocales</a></td></tr>
<tr class="memdesc:a5ad97890f7e65216346befddd270c858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locale used when converting the field with the same array index to a date/time.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a5ad97890f7e65216346befddd270c858">More...</a><br /></td></tr>
<tr class="separator:a5ad97890f7e65216346befddd270c858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120a36da482944ccac8744f20516d5bb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a120a36da482944ccac8744f20516d5bb">extractingFieldDelimiters</a></td></tr>
<tr class="memdesc:a120a36da482944ccac8744f20516d5bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delimiter between multiple results for the field with the same array index, if not saved as JSON.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a120a36da482944ccac8744f20516d5bb">More...</a><br /></td></tr>
<tr class="separator:a120a36da482944ccac8744f20516d5bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a604193c68dd258d65059d997bbab7889"><td class="memItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a604193c68dd258d65059d997bbab7889">extractingFieldIgnoreEmpty</a></td></tr>
<tr class="memdesc:a604193c68dd258d65059d997bbab7889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether to ignore empty values when parsing multiple results for the field with the same array index.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a604193c68dd258d65059d997bbab7889">More...</a><br /></td></tr>
<tr class="separator:a604193c68dd258d65059d997bbab7889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e512c6d01a02a3d80654ac0382d347e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a3e512c6d01a02a3d80654ac0382d347e">extractingFieldJSON</a></td></tr>
<tr class="memdesc:a3e512c6d01a02a3d80654ac0382d347e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the value of the field with the same array index as a JSON array.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a3e512c6d01a02a3d80654ac0382d347e">More...</a><br /></td></tr>
<tr class="separator:a3e512c6d01a02a3d80654ac0382d347e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e655d7ac2816df979a173e5bc0c98c6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a2e655d7ac2816df979a173e5bc0c98c6">extractingFieldNames</a></td></tr>
<tr class="memdesc:a2e655d7ac2816df979a173e5bc0c98c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The names of the custom fields to extract.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a2e655d7ac2816df979a173e5bc0c98c6">More...</a><br /></td></tr>
<tr class="separator:a2e655d7ac2816df979a173e5bc0c98c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace423e6cbc7a3dc1dd3be33c52491f2b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ace423e6cbc7a3dc1dd3be33c52491f2b">extractingFieldQueries</a></td></tr>
<tr class="memdesc:ace423e6cbc7a3dc1dd3be33c52491f2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The query used to extract the custom field with the same array index from the data.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ace423e6cbc7a3dc1dd3be33c52491f2b">More...</a><br /></td></tr>
<tr class="separator:ace423e6cbc7a3dc1dd3be33c52491f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715deb90f3f25dd02d7ace66c35cf63e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a715deb90f3f25dd02d7ace66c35cf63e">extractingFieldTidyTexts</a></td></tr>
<tr class="memdesc:a715deb90f3f25dd02d7ace66c35cf63e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether to remove line breaks and unnecessary spaces when extracting the field with the same array index.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a715deb90f3f25dd02d7ace66c35cf63e">More...</a><br /></td></tr>
<tr class="separator:a715deb90f3f25dd02d7ace66c35cf63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa152b9b02452bb6229a8d24a05b7e896"><td class="memItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#aa152b9b02452bb6229a8d24a05b7e896">extractingFieldWarningsEmpty</a></td></tr>
<tr class="memdesc:aa152b9b02452bb6229a8d24a05b7e896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether to write a warning to the log when the field with the same array index is empty.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#aa152b9b02452bb6229a8d24a05b7e896">More...</a><br /></td></tr>
<tr class="separator:aa152b9b02452bb6229a8d24a05b7e896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3667217f997055fdd741182e25de2744"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a3667217f997055fdd741182e25de2744">extractingIdIgnore</a></td></tr>
<tr class="memdesc:a3667217f997055fdd741182e25de2744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracted IDs to be ignored.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a3667217f997055fdd741182e25de2744">More...</a><br /></td></tr>
<tr class="separator:a3667217f997055fdd741182e25de2744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15078553e1a5c0eb44281053ed238b95"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a15078553e1a5c0eb44281053ed238b95">extractingIdQueries</a></td></tr>
<tr class="memdesc:a15078553e1a5c0eb44281053ed238b95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries to extract the ID from the dataset.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a15078553e1a5c0eb44281053ed238b95">More...</a><br /></td></tr>
<tr class="separator:a15078553e1a5c0eb44281053ed238b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f311b4389d46dd2d0a185fd352a12b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a2f311b4389d46dd2d0a185fd352a12b0">extractingOverwrite</a> {true}</td></tr>
<tr class="memdesc:a2f311b4389d46dd2d0a185fd352a12b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether, if a dataset with the same ID already exists, it will be overwritten.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a2f311b4389d46dd2d0a185fd352a12b0">More...</a><br /></td></tr>
<tr class="separator:a2f311b4389d46dd2d0a185fd352a12b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a85b8a42d171413302ed9de30775fd"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a07a85b8a42d171413302ed9de30775fd">extractingRecursive</a></td></tr>
<tr class="memdesc:a07a85b8a42d171413302ed9de30775fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries for extracting more datasets from a dataset.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a07a85b8a42d171413302ed9de30775fd">More...</a><br /></td></tr>
<tr class="separator:a07a85b8a42d171413302ed9de30775fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7e200e090db209745fcc1a31dac72c"><td class="memItemLeft" align="right" valign="top">std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#afc7e200e090db209745fcc1a31dac72c">extractingRecursiveMaxDepth</a> {<a class="el" href="namespacecrawlservpp_1_1Module_1_1Extractor.html#a90cb69ce17b1596568eca5efef668a87">defaultRecursiveMaxDepth</a>}</td></tr>
<tr class="memdesc:afc7e200e090db209745fcc1a31dac72c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum depth of recursive extracting.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#afc7e200e090db209745fcc1a31dac72c">More...</a><br /></td></tr>
<tr class="separator:afc7e200e090db209745fcc1a31dac72c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d01e5336f9852501ffb5f6ea38bd4c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a8d01e5336f9852501ffb5f6ea38bd4c4">extractingRemoveDuplicates</a> {true}</td></tr>
<tr class="memdesc:a8d01e5336f9852501ffb5f6ea38bd4c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether to remove duplicate datasets over multiple pages before checking the expected number of datasets.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a8d01e5336f9852501ffb5f6ea38bd4c4">More...</a><br /></td></tr>
<tr class="separator:a8d01e5336f9852501ffb5f6ea38bd4c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eef88ef16cf9565b2ded233e938bd8d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a2eef88ef16cf9565b2ded233e938bd8d">extractingRepairCData</a> {true}</td></tr>
<tr class="memdesc:a2eef88ef16cf9565b2ded233e938bd8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether to (try to) repair CData when parsing HTML/XML.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a2eef88ef16cf9565b2ded233e938bd8d">More...</a><br /></td></tr>
<tr class="separator:a2eef88ef16cf9565b2ded233e938bd8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea10ecaa4f46797f04243bc412aa9902"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#aea10ecaa4f46797f04243bc412aa9902">extractingRepairComments</a> {true}</td></tr>
<tr class="memdesc:aea10ecaa4f46797f04243bc412aa9902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether to (try to) repair broken HTML/XML comments.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#aea10ecaa4f46797f04243bc412aa9902">More...</a><br /></td></tr>
<tr class="separator:aea10ecaa4f46797f04243bc412aa9902"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Linked Data</h2></td></tr>
<tr class="memitem:a5ebf45092430872bec62ea5ddc0eda2a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a5ebf45092430872bec62ea5ddc0eda2a">linkedDatasetQueries</a></td></tr>
<tr class="memdesc:a5ebf45092430872bec62ea5ddc0eda2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries to extract linked datasets.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a5ebf45092430872bec62ea5ddc0eda2a">More...</a><br /></td></tr>
<tr class="separator:a5ebf45092430872bec62ea5ddc0eda2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab590b5bff61a90b484ed0595152429ee"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ab590b5bff61a90b484ed0595152429ee">linkedDateTimeFormats</a></td></tr>
<tr class="memdesc:ab590b5bff61a90b484ed0595152429ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Date/time format of the linked field with the same array index.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ab590b5bff61a90b484ed0595152429ee">More...</a><br /></td></tr>
<tr class="separator:ab590b5bff61a90b484ed0595152429ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f9f8aefbf5859c61c4fd8e7f8d4b6e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ad3f9f8aefbf5859c61c4fd8e7f8d4b6e">linkedDateTimeLocales</a></td></tr>
<tr class="memdesc:ad3f9f8aefbf5859c61c4fd8e7f8d4b6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Date/time locale of the linked field with the same array index.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ad3f9f8aefbf5859c61c4fd8e7f8d4b6e">More...</a><br /></td></tr>
<tr class="separator:ad3f9f8aefbf5859c61c4fd8e7f8d4b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a970e3646d402d5891c4f70b04f1692d9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a970e3646d402d5891c4f70b04f1692d9">linkedDelimiters</a></td></tr>
<tr class="memdesc:a970e3646d402d5891c4f70b04f1692d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delimiter between multiple results for the field with the same array index, if not saved as JSON.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a970e3646d402d5891c4f70b04f1692d9">More...</a><br /></td></tr>
<tr class="separator:a970e3646d402d5891c4f70b04f1692d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab27fb9de859979611e88daebad0e12d5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ab27fb9de859979611e88daebad0e12d5">linkedFieldNames</a></td></tr>
<tr class="memdesc:ab27fb9de859979611e88daebad0e12d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Names of the linked data fields.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ab27fb9de859979611e88daebad0e12d5">More...</a><br /></td></tr>
<tr class="separator:ab27fb9de859979611e88daebad0e12d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cdab1c70b2501bada1bb42bad9a6449"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a8cdab1c70b2501bada1bb42bad9a6449">linkedFieldQueries</a></td></tr>
<tr class="memdesc:a8cdab1c70b2501bada1bb42bad9a6449"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacecrawlservpp_1_1Query.html" title="Namespace for classes handling queries.">Query</a> used to extract the custom field with the same array index from the dataset.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a8cdab1c70b2501bada1bb42bad9a6449">More...</a><br /></td></tr>
<tr class="separator:a8cdab1c70b2501bada1bb42bad9a6449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38dc0e9fac05b14efa789987a91cedb2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a38dc0e9fac05b14efa789987a91cedb2">linkedIdIgnore</a></td></tr>
<tr class="memdesc:a38dc0e9fac05b14efa789987a91cedb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">IDs of linked data to be ignored.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a38dc0e9fac05b14efa789987a91cedb2">More...</a><br /></td></tr>
<tr class="separator:a38dc0e9fac05b14efa789987a91cedb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d73811430cabea74de295be7b17ce5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a17d73811430cabea74de295be7b17ce5">linkedIdQueries</a></td></tr>
<tr class="memdesc:a17d73811430cabea74de295be7b17ce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries to extract the linked ID from the dataset.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a17d73811430cabea74de295be7b17ce5">More...</a><br /></td></tr>
<tr class="separator:a17d73811430cabea74de295be7b17ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f43cc9a977489162aba9f4f1114213"><td class="memItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a99f43cc9a977489162aba9f4f1114213">linkedIgnoreEmpty</a></td></tr>
<tr class="memdesc:a99f43cc9a977489162aba9f4f1114213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether to ignore empty values when parsing multiple results for the field with the same array index.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a99f43cc9a977489162aba9f4f1114213">More...</a><br /></td></tr>
<tr class="separator:a99f43cc9a977489162aba9f4f1114213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b3ac7815fc0dd93dbea52ea347d713f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a3b3ac7815fc0dd93dbea52ea347d713f">linkedJSON</a></td></tr>
<tr class="memdesc:a3b3ac7815fc0dd93dbea52ea347d713f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specfies whether to save the value of the field with the same array index as a JSON array.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a3b3ac7815fc0dd93dbea52ea347d713f">More...</a><br /></td></tr>
<tr class="separator:a3b3ac7815fc0dd93dbea52ea347d713f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e42d5ddd2e449e66c9fd7841440e8d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a62e42d5ddd2e449e66c9fd7841440e8d">linkedLink</a></td></tr>
<tr class="memdesc:a62e42d5ddd2e449e66c9fd7841440e8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of the extracted field that links an extracted dataset to the ID of a linked dataset.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a62e42d5ddd2e449e66c9fd7841440e8d">More...</a><br /></td></tr>
<tr class="separator:a62e42d5ddd2e449e66c9fd7841440e8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c1b0e29fe04f399294fdd9a8e174fb7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a0c1b0e29fe04f399294fdd9a8e174fb7">linkedOverwrite</a> {true}</td></tr>
<tr class="memdesc:a0c1b0e29fe04f399294fdd9a8e174fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether, if a linked dataset with the same ID already exists, it will be overwritten.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a0c1b0e29fe04f399294fdd9a8e174fb7">More...</a><br /></td></tr>
<tr class="separator:a0c1b0e29fe04f399294fdd9a8e174fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c33df4d8566c1f20ef9879d7adad88d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a5c33df4d8566c1f20ef9879d7adad88d">linkedTargetTable</a></td></tr>
<tr class="memdesc:a5c33df4d8566c1f20ef9879d7adad88d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of the table to save linked data to.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a5c33df4d8566c1f20ef9879d7adad88d">More...</a><br /></td></tr>
<tr class="separator:a5c33df4d8566c1f20ef9879d7adad88d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac155832fc2e12ed2dce7ad792afa9d0b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ac155832fc2e12ed2dce7ad792afa9d0b">linkedTidyTexts</a></td></tr>
<tr class="memdesc:ac155832fc2e12ed2dce7ad792afa9d0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether to remove line breaks and unnecessary spaces when extracting the linked field with the same array index.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ac155832fc2e12ed2dce7ad792afa9d0b">More...</a><br /></td></tr>
<tr class="separator:ac155832fc2e12ed2dce7ad792afa9d0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3774e1f6c5a578c967526af8cb31343"><td class="memItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#af3774e1f6c5a578c967526af8cb31343">linkedWarningsEmpty</a></td></tr>
<tr class="memdesc:af3774e1f6c5a578c967526af8cb31343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether to write a warning to the log when the field with the same array index is empty.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#af3774e1f6c5a578c967526af8cb31343">More...</a><br /></td></tr>
<tr class="separator:af3774e1f6c5a578c967526af8cb31343"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Expected Number of Results</h2></td></tr>
<tr class="memitem:a49cdac20db007e90813a3146be811dd5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a49cdac20db007e90813a3146be811dd5">expectedErrorIfLarger</a> {false}</td></tr>
<tr class="memdesc:a49cdac20db007e90813a3146be811dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether to throw an exception when the number of expected datasets is exceeded.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a49cdac20db007e90813a3146be811dd5">More...</a><br /></td></tr>
<tr class="separator:a49cdac20db007e90813a3146be811dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c82859677122582ffc1c76fc981ef3f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a4c82859677122582ffc1c76fc981ef3f">expectedErrorIfSmaller</a> {false}</td></tr>
<tr class="memdesc:a4c82859677122582ffc1c76fc981ef3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether to throw an exception when the number of expected datasets is subceeded.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a4c82859677122582ffc1c76fc981ef3f">More...</a><br /></td></tr>
<tr class="separator:a4c82859677122582ffc1c76fc981ef3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af77bf723a0da2bc814b9af88f1a111d1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#af77bf723a0da2bc814b9af88f1a111d1">expectedParsedColumn</a></td></tr>
<tr class="memdesc:af77bf723a0da2bc814b9af88f1a111d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parsed column containing the expected number of datasets.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#af77bf723a0da2bc814b9af88f1a111d1">More...</a><br /></td></tr>
<tr class="separator:af77bf723a0da2bc814b9af88f1a111d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4c8f7457aee615157ca06131850272"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#afe4c8f7457aee615157ca06131850272">expectedParsedTable</a></td></tr>
<tr class="memdesc:afe4c8f7457aee615157ca06131850272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of the table containing the expected number of datasets.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#afe4c8f7457aee615157ca06131850272">More...</a><br /></td></tr>
<tr class="separator:afe4c8f7457aee615157ca06131850272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd0170af2a77decfe80099c81647ff4d"><td class="memItemLeft" align="right" valign="top">std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#abd0170af2a77decfe80099c81647ff4d">expectedQuery</a> {0}</td></tr>
<tr class="memdesc:abd0170af2a77decfe80099c81647ff4d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespacecrawlservpp_1_1Query.html" title="Namespace for classes handling queries.">Query</a> to be performed to retrieve the expected number of datasets.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#abd0170af2a77decfe80099c81647ff4d">More...</a><br /></td></tr>
<tr class="separator:abd0170af2a77decfe80099c81647ff4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71be4d3aa9dccf91a95e8e54dd0a0c9"><td class="memItemLeft" align="right" valign="top">std::uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#af71be4d3aa9dccf91a95e8e54dd0a0c9">expectedSource</a> {<a class="el" href="namespacecrawlservpp_1_1Module_1_1Extractor.html#a828fa85eb473b22f9483f37ca6db4180">expectedSourceExtracting</a>}</td></tr>
<tr class="memdesc:af71be4d3aa9dccf91a95e8e54dd0a0c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Source of the query to retrieve the expected number of datasets.  <a href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#af71be4d3aa9dccf91a95e8e54dd0a0c9">More...</a><br /></td></tr>
<tr class="separator:af71be4d3aa9dccf91a95e8e54dd0a0c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Configuration entries for extractor threads. </p>
<dl class="section warning"><dt>Warning</dt><dd>Changing the configuration requires updating <code>json/extractor.json</code> in <code>crawlserv_frontend!</code> </dd></dl>
</div><h2 class="groupheader">Member Data Documentation</h2>
<a id="a49cdac20db007e90813a3146be811dd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49cdac20db007e90813a3146be811dd5">&#9670;&nbsp;</a></span>expectedErrorIfLarger</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crawlservpp::Module::Extractor::Config::Entries::expectedErrorIfLarger {false}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies whether to throw an exception when the number of expected datasets is exceeded. </p>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a4c82859677122582ffc1c76fc981ef3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c82859677122582ffc1c76fc981ef3f">&#9670;&nbsp;</a></span>expectedErrorIfSmaller</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crawlservpp::Module::Extractor::Config::Entries::expectedErrorIfSmaller {false}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies whether to throw an exception when the number of expected datasets is subceeded. </p>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="af77bf723a0da2bc814b9af88f1a111d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af77bf723a0da2bc814b9af88f1a111d1">&#9670;&nbsp;</a></span>expectedParsedColumn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string crawlservpp::Module::Extractor::Config::Entries::expectedParsedColumn</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parsed column containing the expected number of datasets. </p>
<dl class="section note"><dt>Note</dt><dd>Will only be used, if parsed data is the source of the expected number of datasets.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#af71be4d3aa9dccf91a95e8e54dd0a0c9" title="Source of the query to retrieve the expected number of datasets.">expectedSource</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="afe4c8f7457aee615157ca06131850272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe4c8f7457aee615157ca06131850272">&#9670;&nbsp;</a></span>expectedParsedTable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string crawlservpp::Module::Extractor::Config::Entries::expectedParsedTable</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Name of the table containing the expected number of datasets. </p>
<dl class="section note"><dt>Note</dt><dd>Will only be used, if parsed data is the source of the expected number of datasets.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#af71be4d3aa9dccf91a95e8e54dd0a0c9" title="Source of the query to retrieve the expected number of datasets.">expectedSource</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="abd0170af2a77decfe80099c81647ff4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd0170af2a77decfe80099c81647ff4d">&#9670;&nbsp;</a></span>expectedQuery</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t crawlservpp::Module::Extractor::Config::Entries::expectedQuery {0}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespacecrawlservpp_1_1Query.html" title="Namespace for classes handling queries.">Query</a> to be performed to retrieve the expected number of datasets. </p>
<dl class="section note"><dt>Note</dt><dd>Will only be used, if the content or the URL is the source of the expected number of datasets.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#af71be4d3aa9dccf91a95e8e54dd0a0c9" title="Source of the query to retrieve the expected number of datasets.">expectedSource</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="af71be4d3aa9dccf91a95e8e54dd0a0c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af71be4d3aa9dccf91a95e8e54dd0a0c9">&#9670;&nbsp;</a></span>expectedSource</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint8_t crawlservpp::Module::Extractor::Config::Entries::expectedSource {<a class="el" href="namespacecrawlservpp_1_1Module_1_1Extractor.html#a828fa85eb473b22f9483f37ca6db4180">expectedSourceExtracting</a>}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Source of the query to retrieve the expected number of datasets. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacecrawlservpp_1_1Module_1_1Extractor.html#a828fa85eb473b22f9483f37ca6db4180" title="Extract data from other extracted data.">expectedSourceExtracting</a>, <a class="el" href="namespacecrawlservpp_1_1Module_1_1Extractor.html#a3566481eb2a163d31a97cb5e7fe39958" title="Extract data from parsed data.">expectedSourceParsed</a>, <a class="el" href="namespacecrawlservpp_1_1Module_1_1Extractor.html#a59318c06bedb3992e3a98f637b996689" title="Extract data from the content of a crawled web page.">expectedSourceContent</a>, <a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#abd0170af2a77decfe80099c81647ff4d" title="Query to be performed to retrieve the expected number of datasets.">expectedQuery</a>, <a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#afe4c8f7457aee615157ca06131850272" title="Name of the table containing the expected number of datasets.">expectedParsedTable</a>, <a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#af77bf723a0da2bc814b9af88f1a111d1" title="Parsed column containing the expected number of datasets.">expectedParsedColumn</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a94b4fa0a7fd9a5c93804650ad132d0e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94b4fa0a7fd9a5c93804650ad132d0e3">&#9670;&nbsp;</a></span>extractingDatasetQueries</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::uint64_t&gt; crawlservpp::Module::Extractor::Config::Entries::extractingDatasetQueries</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queries to extract datasets. </p>
<p>The first query that returns a non-empty result will be used. </p>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Thread.html#a8beba4474faa5bf4b0d3fed98557a3f3">crawlservpp::Module::Extractor::Thread::onInit()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a4134a28dce4376e11a68517cb3395e98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4134a28dce4376e11a68517cb3395e98">&#9670;&nbsp;</a></span>extractingDateTimeFormats</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; crawlservpp::Module::Extractor::Config::Entries::extractingDateTimeFormats</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format of date/time to be extracted by the date/time query with the same array index. </p>
<p>If not specified, the format <code>%F</code> <code>%T</code>, i.e. <code>YYYY-MM-DD</code> HH:MM:SS will be used.</p>
<p>See Howard E. Hinnant's <a href="https://howardhinnant.github.io/date/date.html#from_stream_formatting">C++ <code>date.h</code> library documentation</a> for details.</p>
<p>Set a string to <code>UNIX</code> to parse Unix timestamps, i.e. seconds since the Unix epoch, instead.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a081b6756ae773864a600f44123bff061" title="Queries used for extracting date/time from the dataset.">extractingDateTimeQueries</a>, <a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a8b6726de8d9a9070058e40c91ec29b21" title="Locale used by the date/time query with the same array index for extracting date and time.">extractingDateTimeLocales</a>, <a class="el" href="namespacecrawlservpp_1_1Helper_1_1DateTime.html#ab1133490ed8dd299712c6642107b15fb" title="Converts date/time with a custom format into the format YYYY-MM-DD HH:MM:SS.">Helper::DateTime::convertCustomDateTimeToSQLTimeStamp</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a23e5c1309ed4550f471919078784e3ea">crawlservpp::Module::Extractor::Config::checkOptions()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a8b6726de8d9a9070058e40c91ec29b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b6726de8d9a9070058e40c91ec29b21">&#9670;&nbsp;</a></span>extractingDateTimeLocales</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; crawlservpp::Module::Extractor::Config::Entries::extractingDateTimeLocales</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locale used by the date/time query with the same array index for extracting date and time. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a081b6756ae773864a600f44123bff061" title="Queries used for extracting date/time from the dataset.">extractingDateTimeQueries</a>, <a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a8b6726de8d9a9070058e40c91ec29b21" title="Locale used by the date/time query with the same array index for extracting date and time.">extractingDateTimeLocales</a>, <a class="el" href="namespacecrawlservpp_1_1Helper_1_1DateTime.html#ab1133490ed8dd299712c6642107b15fb" title="Converts date/time with a custom format into the format YYYY-MM-DD HH:MM:SS.">Helper::DateTime::convertCustomDateTimeToSQLTimeStamp</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a23e5c1309ed4550f471919078784e3ea">crawlservpp::Module::Extractor::Config::checkOptions()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a081b6756ae773864a600f44123bff061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a081b6756ae773864a600f44123bff061">&#9670;&nbsp;</a></span>extractingDateTimeQueries</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::uint64_t&gt; crawlservpp::Module::Extractor::Config::Entries::extractingDateTimeQueries</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queries used for extracting date/time from the dataset. </p>
<p>The first query that returns a non-empty result will be used.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a4134a28dce4376e11a68517cb3395e98" title="Format of date/time to be extracted by the date/time query with the same array index.">extractingDateTimeFormats</a>, extractingDateTimeLoclaes </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a23e5c1309ed4550f471919078784e3ea">crawlservpp::Module::Extractor::Config::checkOptions()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a02198b039d023566f18b4bf1e8efcbd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02198b039d023566f18b4bf1e8efcbd8">&#9670;&nbsp;</a></span>extractingErrorFail</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::uint64_t&gt; crawlservpp::Module::Extractor::Config::Entries::extractingErrorFail</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queries to detect fatal errors in the data. </p>
<p>The extraction will fail, if any of these queries return <code>true</code>. </p>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a676fdfe96a323f8b8355795b752e2c60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a676fdfe96a323f8b8355795b752e2c60">&#9670;&nbsp;</a></span>extractingErrorRetry</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::uint64_t&gt; crawlservpp::Module::Extractor::Config::Entries::extractingErrorRetry</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queries to detect temporary errors in the data. </p>
<p>The extraction will be retried, as long as any of these queries return <code>true</code>. </p>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a25490b2d7bf3b42fc52f376d9b1c957c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25490b2d7bf3b42fc52f376d9b1c957c">&#9670;&nbsp;</a></span>extractingFieldDateTimeFormats</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; crawlservpp::Module::Extractor::Config::Entries::extractingFieldDateTimeFormats</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Date/time format of the field with the same array index. </p>
<p>If empty, no date/time conversion will be performed.</p>
<p>See Howard E. Hinnant's <a href="https://howardhinnant.github.io/date/date.html#from_stream_formatting">C++ <code>date.h</code> library documentation</a> for details.</p>
<p>Set a string to <code>UNIX</code> to parse Unix timestamps, i.e. seconds since the Unix epoch, instead.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a2e655d7ac2816df979a173e5bc0c98c6" title="The names of the custom fields to extract.">extractingFieldNames</a>, <a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a5ad97890f7e65216346befddd270c858" title="Locale used when converting the field with the same array index to a date/time.">extractingFieldDateTimeLocales</a>, <a class="el" href="namespacecrawlservpp_1_1Helper_1_1DateTime.html#ab1133490ed8dd299712c6642107b15fb" title="Converts date/time with a custom format into the format YYYY-MM-DD HH:MM:SS.">Helper::DateTime::convertCustomDateTimeToSQLTimeStamp</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a23e5c1309ed4550f471919078784e3ea">crawlservpp::Module::Extractor::Config::checkOptions()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a5ad97890f7e65216346befddd270c858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ad97890f7e65216346befddd270c858">&#9670;&nbsp;</a></span>extractingFieldDateTimeLocales</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; crawlservpp::Module::Extractor::Config::Entries::extractingFieldDateTimeLocales</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locale used when converting the field with the same array index to a date/time. </p>
<p>Will be ignored, if no date/time format has been specified for the field.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a2e655d7ac2816df979a173e5bc0c98c6" title="The names of the custom fields to extract.">extractingFieldNames</a>, <a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a25490b2d7bf3b42fc52f376d9b1c957c" title="Date/time format of the field with the same array index.">extractingFieldDateTimeFormats</a>, <a class="el" href="namespacecrawlservpp_1_1Helper_1_1DateTime.html#ab1133490ed8dd299712c6642107b15fb" title="Converts date/time with a custom format into the format YYYY-MM-DD HH:MM:SS.">Helper::DateTime::convertCustomDateTimeToSQLTimeStamp</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a23e5c1309ed4550f471919078784e3ea">crawlservpp::Module::Extractor::Config::checkOptions()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a120a36da482944ccac8744f20516d5bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a120a36da482944ccac8744f20516d5bb">&#9670;&nbsp;</a></span>extractingFieldDelimiters</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;char&gt; crawlservpp::Module::Extractor::Config::Entries::extractingFieldDelimiters</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delimiter between multiple results for the field with the same array index, if not saved as JSON. </p>
<p>Only the first character of the string, <code>\n</code> (default), <code>\t</code>, or <code>\\</code> will be used.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a2e655d7ac2816df979a173e5bc0c98c6" title="The names of the custom fields to extract.">extractingFieldNames</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a23e5c1309ed4550f471919078784e3ea">crawlservpp::Module::Extractor::Config::checkOptions()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a604193c68dd258d65059d997bbab7889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a604193c68dd258d65059d997bbab7889">&#9670;&nbsp;</a></span>extractingFieldIgnoreEmpty</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;bool&gt; crawlservpp::Module::Extractor::Config::Entries::extractingFieldIgnoreEmpty</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies whether to ignore empty values when parsing multiple results for the field with the same array index. </p>
<p>Enabled by default.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a2e655d7ac2816df979a173e5bc0c98c6" title="The names of the custom fields to extract.">extractingFieldNames</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a23e5c1309ed4550f471919078784e3ea">crawlservpp::Module::Extractor::Config::checkOptions()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a3e512c6d01a02a3d80654ac0382d347e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e512c6d01a02a3d80654ac0382d347e">&#9670;&nbsp;</a></span>extractingFieldJSON</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;bool&gt; crawlservpp::Module::Extractor::Config::Entries::extractingFieldJSON</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save the value of the field with the same array index as a JSON array. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a2e655d7ac2816df979a173e5bc0c98c6" title="The names of the custom fields to extract.">extractingFieldNames</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a23e5c1309ed4550f471919078784e3ea">crawlservpp::Module::Extractor::Config::checkOptions()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a2e655d7ac2816df979a173e5bc0c98c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e655d7ac2816df979a173e5bc0c98c6">&#9670;&nbsp;</a></span>extractingFieldNames</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; crawlservpp::Module::Extractor::Config::Entries::extractingFieldNames</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The names of the custom fields to extract. </p>
<p>These fields will be extracted from the content of the current page, using the queries specified in <a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ace423e6cbc7a3dc1dd3be33c52491f2b" title="The query used to extract the custom field with the same array index from the data.">Extractor::Config::Entries::extractingFieldQueries</a>.</p>
<p>Field options are matched via the array index in the respective vectors.</p>
<p>If <a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a25490b2d7bf3b42fc52f376d9b1c957c" title="Date/time format of the field with the same array index.">Extractor::Config::Entries::extractingFieldDateTimeFormats</a> contains a non-empty string, a date/time will be parsed for the respective field, using the locale defined in Extractor::Config::Entries::extractingFieldDateTimeLocale.</p>
<p>Multiple values for one field will be detected via the delimiter in <a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a120a36da482944ccac8744f20516d5bb" title="Delimiter between multiple results for the field with the same array index, if not saved as JSON.">Extractor::Config::Entries::extractingFieldDelimiters</a>, <a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a604193c68dd258d65059d997bbab7889" title="Specifies whether to ignore empty values when parsing multiple results for the field with the same ar...">Extractor::Config::Entries::extractingFieldIgnoreEmpty</a> determines whether to ignore empty values, and <a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a3e512c6d01a02a3d80654ac0382d347e" title="Save the value of the field with the same array index as a JSON array.">Extractor::Config::Entries::extractingFieldJSON</a> whether to store them as a JSON array.</p>
<p>If the value of a field is empty, <a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#aa152b9b02452bb6229a8d24a05b7e896" title="Specifies whether to write a warning to the log when the field with the same array index is empty.">Extractor::Config::Entries::extractingFieldWarningsEmpty</a> determines whether to write a warning to the log.</p>
<p><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a715deb90f3f25dd02d7ace66c35cf63e" title="Specifies whether to remove line breaks and unnecessary spaces when extracting the field with the sam...">Extractor::Config::Entries::extractingFieldTidyTexts</a> specifies whether to tidy up the resulting text before being stored to the respective field. </p>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a23e5c1309ed4550f471919078784e3ea">crawlservpp::Module::Extractor::Config::checkOptions()</a>, <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Thread.html#a8beba4474faa5bf4b0d3fed98557a3f3">crawlservpp::Module::Extractor::Thread::onInit()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="ace423e6cbc7a3dc1dd3be33c52491f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace423e6cbc7a3dc1dd3be33c52491f2b">&#9670;&nbsp;</a></span>extractingFieldQueries</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::uint64_t&gt; crawlservpp::Module::Extractor::Config::Entries::extractingFieldQueries</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The query used to extract the custom field with the same array index from the data. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a2e655d7ac2816df979a173e5bc0c98c6" title="The names of the custom fields to extract.">extractingFieldNames</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a23e5c1309ed4550f471919078784e3ea">crawlservpp::Module::Extractor::Config::checkOptions()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a715deb90f3f25dd02d7ace66c35cf63e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a715deb90f3f25dd02d7ace66c35cf63e">&#9670;&nbsp;</a></span>extractingFieldTidyTexts</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;bool&gt; crawlservpp::Module::Extractor::Config::Entries::extractingFieldTidyTexts</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies whether to remove line breaks and unnecessary spaces when extracting the field with the same array index. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a2e655d7ac2816df979a173e5bc0c98c6" title="The names of the custom fields to extract.">extractingFieldNames</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a23e5c1309ed4550f471919078784e3ea">crawlservpp::Module::Extractor::Config::checkOptions()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="aa152b9b02452bb6229a8d24a05b7e896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa152b9b02452bb6229a8d24a05b7e896">&#9670;&nbsp;</a></span>extractingFieldWarningsEmpty</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;bool&gt; crawlservpp::Module::Extractor::Config::Entries::extractingFieldWarningsEmpty</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies whether to write a warning to the log when the field with the same array index is empty. </p>
<dl class="section note"><dt>Note</dt><dd>Logging needs to be enabled in order for this option to have any effect.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a2e655d7ac2816df979a173e5bc0c98c6" title="The names of the custom fields to extract.">extractingFieldNames</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a23e5c1309ed4550f471919078784e3ea">crawlservpp::Module::Extractor::Config::checkOptions()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a3667217f997055fdd741182e25de2744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3667217f997055fdd741182e25de2744">&#9670;&nbsp;</a></span>extractingIdIgnore</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; crawlservpp::Module::Extractor::Config::Entries::extractingIdIgnore</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracted IDs to be ignored. </p>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a15078553e1a5c0eb44281053ed238b95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15078553e1a5c0eb44281053ed238b95">&#9670;&nbsp;</a></span>extractingIdQueries</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::uint64_t&gt; crawlservpp::Module::Extractor::Config::Entries::extractingIdQueries</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queries to extract the ID from the dataset. </p>
<p>The first query that returns a non-empty result will be used. Datasets with duplicate or empty IDs will not be extracted. </p>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Thread.html#a8beba4474faa5bf4b0d3fed98557a3f3">crawlservpp::Module::Extractor::Thread::onInit()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a2f311b4389d46dd2d0a185fd352a12b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f311b4389d46dd2d0a185fd352a12b0">&#9670;&nbsp;</a></span>extractingOverwrite</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crawlservpp::Module::Extractor::Config::Entries::extractingOverwrite {true}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies whether, if a dataset with the same ID already exists, it will be overwritten. </p>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Thread.html#a8beba4474faa5bf4b0d3fed98557a3f3">crawlservpp::Module::Extractor::Thread::onInit()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a07a85b8a42d171413302ed9de30775fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07a85b8a42d171413302ed9de30775fd">&#9670;&nbsp;</a></span>extractingRecursive</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::uint64_t&gt; crawlservpp::Module::Extractor::Config::Entries::extractingRecursive</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queries for extracting more datasets from a dataset. </p>
<p>The first query that returns a non-empty result will be used. </p>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="afc7e200e090db209745fcc1a31dac72c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc7e200e090db209745fcc1a31dac72c">&#9670;&nbsp;</a></span>extractingRecursiveMaxDepth</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t crawlservpp::Module::Extractor::Config::Entries::extractingRecursiveMaxDepth {<a class="el" href="namespacecrawlservpp_1_1Module_1_1Extractor.html#a90cb69ce17b1596568eca5efef668a87">defaultRecursiveMaxDepth</a>}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum depth of recursive extracting. </p>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a8d01e5336f9852501ffb5f6ea38bd4c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d01e5336f9852501ffb5f6ea38bd4c4">&#9670;&nbsp;</a></span>extractingRemoveDuplicates</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crawlservpp::Module::Extractor::Config::Entries::extractingRemoveDuplicates {true}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies whether to remove duplicate datasets over multiple pages before checking the expected number of datasets. </p>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Thread.html#a185a531d9439a05c641e4c4528e5a8e7">crawlservpp::Module::Extractor::Thread::onTick()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a2eef88ef16cf9565b2ded233e938bd8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eef88ef16cf9565b2ded233e938bd8d">&#9670;&nbsp;</a></span>extractingRepairCData</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crawlservpp::Module::Extractor::Config::Entries::extractingRepairCData {true}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies whether to (try to) repair CData when parsing HTML/XML. </p>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Thread.html#a8beba4474faa5bf4b0d3fed98557a3f3">crawlservpp::Module::Extractor::Thread::onInit()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="aea10ecaa4f46797f04243bc412aa9902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea10ecaa4f46797f04243bc412aa9902">&#9670;&nbsp;</a></span>extractingRepairComments</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crawlservpp::Module::Extractor::Config::Entries::extractingRepairComments {true}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies whether to (try to) repair broken HTML/XML comments. </p>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Thread.html#a8beba4474faa5bf4b0d3fed98557a3f3">crawlservpp::Module::Extractor::Thread::onInit()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="aea79feab8a4902c0185dd12459db733a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea79feab8a4902c0185dd12459db733a">&#9670;&nbsp;</a></span>generalCacheSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t crawlservpp::Module::Extractor::Config::Entries::generalCacheSize {<a class="el" href="namespacecrawlservpp_1_1Module_1_1Extractor.html#ae2fd5c01fe236338c3f66d1d241d0d05">defaultCacheSize</a>}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of URLs fetched and extracted from before saving results. </p>
<p>Set to zero to cache all URLs at once. </p>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Thread.html#a8beba4474faa5bf4b0d3fed98557a3f3">crawlservpp::Module::Extractor::Thread::onInit()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a77ed9a229a1b3b0897a567aa9768fb67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77ed9a229a1b3b0897a567aa9768fb67">&#9670;&nbsp;</a></span>generalExtractCustom</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crawlservpp::Module::Extractor::Config::Entries::generalExtractCustom {false}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies whether to include custom URLs when extracting. </p>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Thread.html#a8beba4474faa5bf4b0d3fed98557a3f3">crawlservpp::Module::Extractor::Thread::onInit()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a287b212f48013a10f484dc5ee3d1ef8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a287b212f48013a10f484dc5ee3d1ef8a">&#9670;&nbsp;</a></span>generalLock</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint32_t crawlservpp::Module::Extractor::Config::Entries::generalLock {<a class="el" href="namespacecrawlservpp_1_1Module_1_1Extractor.html#a28a5d5a844057ab9bb7758c5153f8db5">defaultLockS</a>}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>URL locking time, in seconds. </p>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a9398ba1101d2565b864676168801e8ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9398ba1101d2565b864676168801e8ce">&#9670;&nbsp;</a></span>generalLogging</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint8_t crawlservpp::Module::Extractor::Config::Entries::generalLogging {<a class="el" href="namespacecrawlservpp_1_1Module_1_1Extractor.html#a5ebd89ee46e6b9ee7acbf54d20e3112d">generalLoggingDefault</a>}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Level of logging activity. </p>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Thread.html#a8beba4474faa5bf4b0d3fed98557a3f3">crawlservpp::Module::Extractor::Thread::onInit()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="ad813fd72c49e9a51e06b7f9a381d8613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad813fd72c49e9a51e06b7f9a381d8613">&#9670;&nbsp;</a></span>generalMinimizeMemory</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crawlservpp::Module::Extractor::Config::Entries::generalMinimizeMemory {false}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies whether to free small amounts of unused memory more often, at the expense of performance. </p>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Thread.html#a8beba4474faa5bf4b0d3fed98557a3f3">crawlservpp::Module::Extractor::Thread::onInit()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="afef299b6cc113d013577f5fb7ddeb7e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afef299b6cc113d013577f5fb7ddeb7e9">&#9670;&nbsp;</a></span>generalReExtract</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crawlservpp::Module::Extractor::Config::Entries::generalReExtract {false}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies whether to re-extract data from already processed URLs. </p>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Thread.html#a8beba4474faa5bf4b0d3fed98557a3f3">crawlservpp::Module::Extractor::Thread::onInit()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="af58f723f64291bb302f57c1c745623e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af58f723f64291bb302f57c1c745623e8">&#9670;&nbsp;</a></span>generalReTries</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t crawlservpp::Module::Extractor::Config::Entries::generalReTries {<a class="el" href="namespacecrawlservpp_1_1Module_1_1Extractor.html#aeb45747890d65c1325db2c3bef01531e">defaultReTries</a>}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of re-tries on connection errors. </p>
<p>Set to <code>-1</code>, if you want to re-try an infinite number of times on connection errors. </p>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a6251a2518f216fa11c3cf8d766a240d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6251a2518f216fa11c3cf8d766a240d8">&#9670;&nbsp;</a></span>generalRetryHttp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::uint32_t&gt; crawlservpp::Module::Extractor::Config::Entries::generalRetryHttp</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">                <a class="code" href="namespacecrawlservpp_1_1Module_1_1Extractor.html#aa0e6ada78b31ff4e02f856b5b63aac07">defaultRetryHttpStatusCodes</a>.cbegin(),</div>
<div class="line">                <a class="code" href="namespacecrawlservpp_1_1Module_1_1Extractor.html#aa0e6ada78b31ff4e02f856b5b63aac07">defaultRetryHttpStatusCodes</a>.cend()</div>
<div class="line">            }</div>
</div><!-- fragment -->
<p>HTTP errors that will be handled like connection errors. </p>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a488548e0ae622c1c264f8d4a8ee32b6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a488548e0ae622c1c264f8d4a8ee32b6f">&#9670;&nbsp;</a></span>generalSleepError</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t crawlservpp::Module::Extractor::Config::Entries::generalSleepError {<a class="el" href="namespacecrawlservpp_1_1Module_1_1Extractor.html#a8838401e308bcfe8410d3bdaf4197363">defaultSleepErrorMs</a>}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sleeping time (in ms) on connection errors, in milliseconds. </p>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a1b87413044483a01fb42190f8aa12c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b87413044483a01fb42190f8aa12c89">&#9670;&nbsp;</a></span>generalSleepHttp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t crawlservpp::Module::Extractor::Config::Entries::generalSleepHttp {<a class="el" href="namespacecrawlservpp_1_1Module_1_1Extractor.html#ad14b26822b0ca616dd61688368199a9f">defaultSleepHttpMs</a>}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Time that will be waited between HTTP requests, in milliseconds. </p>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="ac99cc25e6b3998f8032a3215f1581359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac99cc25e6b3998f8032a3215f1581359">&#9670;&nbsp;</a></span>generalSleepIdle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t crawlservpp::Module::Extractor::Config::Entries::generalSleepIdle {<a class="el" href="namespacecrawlservpp_1_1Module_1_1Extractor.html#a6a68497febc6364608762a97cff453bb">defaultSleepIdleMs</a>}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Time to wait before checking for new URLs when all URLs have been processed, in milliseconds. </p>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Thread.html#a185a531d9439a05c641e4c4528e5a8e7">crawlservpp::Module::Extractor::Thread::onTick()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a01d350ff1f657de4311c74aa42265cfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01d350ff1f657de4311c74aa42265cfb">&#9670;&nbsp;</a></span>generalSleepMySql</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t crawlservpp::Module::Extractor::Config::Entries::generalSleepMySql {<a class="el" href="namespacecrawlservpp_1_1Module_1_1Extractor.html#a826ccf320a90715d86f08b4f98b64e02">defaultSleepMySqlS</a>}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Time to wait before last try to re-connect to mySQL server, in seconds. </p>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Thread.html#a8beba4474faa5bf4b0d3fed98557a3f3">crawlservpp::Module::Extractor::Thread::onInit()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="ad18b6e6d5a54f9a521fb74891d952cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad18b6e6d5a54f9a521fb74891d952cd1">&#9670;&nbsp;</a></span>generalTargetTable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string crawlservpp::Module::Extractor::Config::Entries::generalTargetTable</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Name of table to save extracted data to. </p>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a23e5c1309ed4550f471919078784e3ea">crawlservpp::Module::Extractor::Config::checkOptions()</a>, <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Thread.html#a8beba4474faa5bf4b0d3fed98557a3f3">crawlservpp::Module::Extractor::Thread::onInit()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="ab6abe78475aa8df84f87bf5d8be03889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6abe78475aa8df84f87bf5d8be03889">&#9670;&nbsp;</a></span>generalTidyErrors</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint32_t crawlservpp::Module::Extractor::Config::Entries::generalTidyErrors {0}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of <code>tidyhtml</code> errors to write to the log. </p>
<dl class="section note"><dt>Note</dt><dd>Logging needs to be enabled in order for this option to have any effect. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a474212c2a7389400665dff626e06037a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a474212c2a7389400665dff626e06037a">&#9670;&nbsp;</a></span>generalTidyWarnings</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crawlservpp::Module::Extractor::Config::Entries::generalTidyWarnings {false}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies whether to write <code>tidyhtml</code> warnings to the log. </p>
<dl class="section note"><dt>Note</dt><dd>Logging needs to be enabled in order for this option to have any effect. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Thread.html#a8beba4474faa5bf4b0d3fed98557a3f3">crawlservpp::Module::Extractor::Thread::onInit()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="ae6aaa53514ae289e6c1a7ca03ea95c38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6aaa53514ae289e6c1a7ca03ea95c38">&#9670;&nbsp;</a></span>generalTiming</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crawlservpp::Module::Extractor::Config::Entries::generalTiming {false}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies whether to calculate timing statistics for the extractor. </p>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Thread.html#a185a531d9439a05c641e4c4528e5a8e7">crawlservpp::Module::Extractor::Thread::onTick()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a5ebf45092430872bec62ea5ddc0eda2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ebf45092430872bec62ea5ddc0eda2a">&#9670;&nbsp;</a></span>linkedDatasetQueries</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::uint64_t&gt; crawlservpp::Module::Extractor::Config::Entries::linkedDatasetQueries</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queries to extract linked datasets. </p>
<p>The first query that returns a non-empty result will be used.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>Not implemented yet.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ab27fb9de859979611e88daebad0e12d5" title="Names of the linked data fields.">linkedFieldNames</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="ab590b5bff61a90b484ed0595152429ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab590b5bff61a90b484ed0595152429ee">&#9670;&nbsp;</a></span>linkedDateTimeFormats</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; crawlservpp::Module::Extractor::Config::Entries::linkedDateTimeFormats</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Date/time format of the linked field with the same array index. </p>
<p>If empty, no date/time conversion will be performed.</p>
<p>See Howard E. Hinnant's <a href="https://howardhinnant.github.io/date/date.html#from_stream_formatting">C++ <code>date.h</code> library documentation</a> for details.</p>
<p>Set a string to <code>UNIX</code> to parse Unix timestamps, i.e. seconds since the Unix epoch, instead.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ab27fb9de859979611e88daebad0e12d5" title="Names of the linked data fields.">linkedFieldNames</a>, <a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ad3f9f8aefbf5859c61c4fd8e7f8d4b6e" title="Date/time locale of the linked field with the same array index.">linkedDateTimeLocales</a>, <a class="el" href="namespacecrawlservpp_1_1Helper_1_1DateTime.html#ab1133490ed8dd299712c6642107b15fb" title="Converts date/time with a custom format into the format YYYY-MM-DD HH:MM:SS.">Helper::DateTime::convertCustomDateTimeToSQLTimeStamp</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a23e5c1309ed4550f471919078784e3ea">crawlservpp::Module::Extractor::Config::checkOptions()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="ad3f9f8aefbf5859c61c4fd8e7f8d4b6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3f9f8aefbf5859c61c4fd8e7f8d4b6e">&#9670;&nbsp;</a></span>linkedDateTimeLocales</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; crawlservpp::Module::Extractor::Config::Entries::linkedDateTimeLocales</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Date/time locale of the linked field with the same array index. </p>
<p>Will be ignored, if no corresponding date/time format is given.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ab27fb9de859979611e88daebad0e12d5" title="Names of the linked data fields.">linkedFieldNames</a>, linkedDateTimeFormat, <a class="el" href="namespacecrawlservpp_1_1Helper_1_1DateTime.html#ab1133490ed8dd299712c6642107b15fb" title="Converts date/time with a custom format into the format YYYY-MM-DD HH:MM:SS.">Helper::DateTime::convertCustomDateTimeToSQLTimeStamp</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a23e5c1309ed4550f471919078784e3ea">crawlservpp::Module::Extractor::Config::checkOptions()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a970e3646d402d5891c4f70b04f1692d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a970e3646d402d5891c4f70b04f1692d9">&#9670;&nbsp;</a></span>linkedDelimiters</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;char&gt; crawlservpp::Module::Extractor::Config::Entries::linkedDelimiters</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delimiter between multiple results for the field with the same array index, if not saved as JSON. </p>
<p>Only the first character, <code>\n</code> (default), <code>\t</code>, or <code>\\</code> will be used.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ab27fb9de859979611e88daebad0e12d5" title="Names of the linked data fields.">linkedFieldNames</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a23e5c1309ed4550f471919078784e3ea">crawlservpp::Module::Extractor::Config::checkOptions()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="ab27fb9de859979611e88daebad0e12d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab27fb9de859979611e88daebad0e12d5">&#9670;&nbsp;</a></span>linkedFieldNames</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; crawlservpp::Module::Extractor::Config::Entries::linkedFieldNames</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Names of the linked data fields. </p>
<p>Linked data is additionally extracted data that is linked via its ID field to one of the originally extracted data fields, as specified in <a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a62e42d5ddd2e449e66c9fd7841440e8d" title="Name of the extracted field that links an extracted dataset to the ID of a linked dataset.">Extractor::Config::Entries::linkedLink</a>.</p>
<p>The ID field, as well as the additional data fields will be extracted from the subset retrieved by using the query in Extractor::Config::Entries::linkedDataSetQueries on the content of the current page, using the queries specified in <a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a17d73811430cabea74de295be7b17ce5" title="Queries to extract the linked ID from the dataset.">Extractor::Config::Entries::linkedIdQueries</a> for the ID, and <a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a8cdab1c70b2501bada1bb42bad9a6449" title="Query used to extract the custom field with the same array index from the dataset.">Extractor::Config::Entries::linkedFieldQueries</a> for each of the other fields.</p>
<p>Linked data with the IDs specified in <a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a38dc0e9fac05b14efa789987a91cedb2" title="IDs of linked data to be ignored.">Extractor::Config::Entries::linkedIdIgnore</a> will be ignored.</p>
<p>Linked field options are matched via the array index in the respective vectors.</p>
<p>If Extractor::Config::Entries::linkedFieldDateTimeFormats contains a non-empty string, a date/time will be parsed for the respective field, using the locale defined in Extractor::Config::Entries::linkedFieldDateTimeLocale.</p>
<p>Multiple values for one field will be detected via the delimiter in Extractor::Config::Entries::linkedFieldDelimiters, Extractor::Config::Entries::linkedFieldIgnoreEmpty determines whether to ignore empty values, and Extractor::Config::Entries::linkedFieldJSON whether to store them as a JSON array.</p>
<p>If the value of a field is empty, <a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#af3774e1f6c5a578c967526af8cb31343" title="Specifies whether to write a warning to the log when the field with the same array index is empty.">Extractor::Config::Entries::linkedWarningsEmpty</a> determines whether to write a warning to the log.</p>
<p><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ac155832fc2e12ed2dce7ad792afa9d0b" title="Specifies whether to remove line breaks and unnecessary spaces when extracting the linked field with ...">Extractor::Config::Entries::linkedTidyTexts</a> specifies whether to tidy up the resulting text before being stored to the respective field.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>Not implemented yet. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a23e5c1309ed4550f471919078784e3ea">crawlservpp::Module::Extractor::Config::checkOptions()</a>, <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Thread.html#a8beba4474faa5bf4b0d3fed98557a3f3">crawlservpp::Module::Extractor::Thread::onInit()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a8cdab1c70b2501bada1bb42bad9a6449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cdab1c70b2501bada1bb42bad9a6449">&#9670;&nbsp;</a></span>linkedFieldQueries</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::uint64_t&gt; crawlservpp::Module::Extractor::Config::Entries::linkedFieldQueries</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespacecrawlservpp_1_1Query.html" title="Namespace for classes handling queries.">Query</a> used to extract the custom field with the same array index from the dataset. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>Not implemented yet.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ab27fb9de859979611e88daebad0e12d5" title="Names of the linked data fields.">linkedFieldNames</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a23e5c1309ed4550f471919078784e3ea">crawlservpp::Module::Extractor::Config::checkOptions()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a38dc0e9fac05b14efa789987a91cedb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38dc0e9fac05b14efa789987a91cedb2">&#9670;&nbsp;</a></span>linkedIdIgnore</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; crawlservpp::Module::Extractor::Config::Entries::linkedIdIgnore</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>IDs of linked data to be ignored. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ab27fb9de859979611e88daebad0e12d5" title="Names of the linked data fields.">linkedFieldNames</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a17d73811430cabea74de295be7b17ce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17d73811430cabea74de295be7b17ce5">&#9670;&nbsp;</a></span>linkedIdQueries</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::uint64_t&gt; crawlservpp::Module::Extractor::Config::Entries::linkedIdQueries</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queries to extract the linked ID from the dataset. </p>
<p>The first query that returns a non-empty result will be used.</p>
<p>Datasets with duplicate or empty IDs will not be extracted.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ab27fb9de859979611e88daebad0e12d5" title="Names of the linked data fields.">linkedFieldNames</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a99f43cc9a977489162aba9f4f1114213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99f43cc9a977489162aba9f4f1114213">&#9670;&nbsp;</a></span>linkedIgnoreEmpty</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;bool&gt; crawlservpp::Module::Extractor::Config::Entries::linkedIgnoreEmpty</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies whether to ignore empty values when parsing multiple results for the field with the same array index. </p>
<p>Enabled by default.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ab27fb9de859979611e88daebad0e12d5" title="Names of the linked data fields.">linkedFieldNames</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a23e5c1309ed4550f471919078784e3ea">crawlservpp::Module::Extractor::Config::checkOptions()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a3b3ac7815fc0dd93dbea52ea347d713f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b3ac7815fc0dd93dbea52ea347d713f">&#9670;&nbsp;</a></span>linkedJSON</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;bool&gt; crawlservpp::Module::Extractor::Config::Entries::linkedJSON</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specfies whether to save the value of the field with the same array index as a JSON array. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ab27fb9de859979611e88daebad0e12d5" title="Names of the linked data fields.">linkedFieldNames</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a23e5c1309ed4550f471919078784e3ea">crawlservpp::Module::Extractor::Config::checkOptions()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a62e42d5ddd2e449e66c9fd7841440e8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62e42d5ddd2e449e66c9fd7841440e8d">&#9670;&nbsp;</a></span>linkedLink</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string crawlservpp::Module::Extractor::Config::Entries::linkedLink</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Name of the extracted field that links an extracted dataset to the ID of a linked dataset. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>Not implemented yet.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ab27fb9de859979611e88daebad0e12d5" title="Names of the linked data fields.">linkedFieldNames</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a0c1b0e29fe04f399294fdd9a8e174fb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c1b0e29fe04f399294fdd9a8e174fb7">&#9670;&nbsp;</a></span>linkedOverwrite</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crawlservpp::Module::Extractor::Config::Entries::linkedOverwrite {true}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies whether, if a linked dataset with the same ID already exists, it will be overwritten. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>Not implemented yet. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Thread.html#a8beba4474faa5bf4b0d3fed98557a3f3">crawlservpp::Module::Extractor::Thread::onInit()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a5c33df4d8566c1f20ef9879d7adad88d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c33df4d8566c1f20ef9879d7adad88d">&#9670;&nbsp;</a></span>linkedTargetTable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string crawlservpp::Module::Extractor::Config::Entries::linkedTargetTable</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Name of the table to save linked data to. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd>Not implemented yet. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Thread.html#a8beba4474faa5bf4b0d3fed98557a3f3">crawlservpp::Module::Extractor::Thread::onInit()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="ac155832fc2e12ed2dce7ad792afa9d0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac155832fc2e12ed2dce7ad792afa9d0b">&#9670;&nbsp;</a></span>linkedTidyTexts</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;bool&gt; crawlservpp::Module::Extractor::Config::Entries::linkedTidyTexts</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies whether to remove line breaks and unnecessary spaces when extracting the linked field with the same array index. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ab27fb9de859979611e88daebad0e12d5" title="Names of the linked data fields.">linkedFieldNames</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a23e5c1309ed4550f471919078784e3ea">crawlservpp::Module::Extractor::Config::checkOptions()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="af3774e1f6c5a578c967526af8cb31343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3774e1f6c5a578c967526af8cb31343">&#9670;&nbsp;</a></span>linkedWarningsEmpty</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;bool&gt; crawlservpp::Module::Extractor::Config::Entries::linkedWarningsEmpty</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies whether to write a warning to the log when the field with the same array index is empty. </p>
<dl class="section note"><dt>Note</dt><dd>Logging needs to be enabled in order for this option to have any effect.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ab27fb9de859979611e88daebad0e12d5" title="Names of the linked data fields.">linkedFieldNames</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a23e5c1309ed4550f471919078784e3ea">crawlservpp::Module::Extractor::Config::checkOptions()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a828ba9f0da22b5e2cd1398fae8bc6337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a828ba9f0da22b5e2cd1398fae8bc6337">&#9670;&nbsp;</a></span>pagingAlias</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string crawlservpp::Module::Extractor::Config::Entries::pagingAlias</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for the paging variable. </p>
<p>A paging alias allows additions to (and subtractions from, via negative values) the current value of the paging variable. The name of the alias will be replaced with the resulting value.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a6d6dd4b76e1a3894c33af1d0a758ecf2" title="Value to add to the alias for the paging variable.">pagingAliasAdd</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a6d6dd4b76e1a3894c33af1d0a758ecf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d6dd4b76e1a3894c33af1d0a758ecf2">&#9670;&nbsp;</a></span>pagingAliasAdd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t crawlservpp::Module::Extractor::Config::Entries::pagingAliasAdd {0}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Value to add to the alias for the paging variable. </p>
<p>Use negative values to subtract from the original value.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a828ba9f0da22b5e2cd1398fae8bc6337" title="Alias for the paging variable.">pagingAlias</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a1c27f27ac6c4455ef9d6fdfab9e5e3ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c27f27ac6c4455ef9d6fdfab9e5e3ef">&#9670;&nbsp;</a></span>pagingFirst</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t crawlservpp::Module::Extractor::Config::Entries::pagingFirst {0}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of the first page. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a12a8a7a5da10b6e8621e48730c73a870" title="Number to add to page variable for retrieving the next page, if a page number is used.">pagingStep</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="af4a0097a5ea5e466c52a703a773f691b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4a0097a5ea5e466c52a703a773f691b">&#9670;&nbsp;</a></span>pagingFirstString</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string crawlservpp::Module::Extractor::Config::Entries::pagingFirstString</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Name of the first page. </p>
<p>If not empty, this string will overwrite <a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a1c27f27ac6c4455ef9d6fdfab9e5e3ef" title="Number of the first page.">Extractor::Config::Entries::pagingFirst</a>. <a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a12a8a7a5da10b6e8621e48730c73a870" title="Number to add to page variable for retrieving the next page, if a page number is used.">Extractor::Config::Entries::pagingStep</a> will also not be used to determine the number of the next page, when a page name is used instead. </p>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="ad1631e2b4e06995f2464c0645e7a1304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1631e2b4e06995f2464c0645e7a1304">&#9670;&nbsp;</a></span>pagingIsNextFrom</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t crawlservpp::Module::Extractor::Config::Entries::pagingIsNextFrom {0}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespacecrawlservpp_1_1Query.html" title="Namespace for classes handling queries.">Query</a> on page content to determine whether there is another page. </p>
<p>Will be ignored, if no query is set, i.e. the value is zero. </p>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="ae840393dfe0c185cee60a69f509b485d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae840393dfe0c185cee60a69f509b485d">&#9670;&nbsp;</a></span>pagingNextFrom</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t crawlservpp::Module::Extractor::Config::Entries::pagingNextFrom {0}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespacecrawlservpp_1_1Query.html" title="Namespace for classes handling queries.">Query</a> on page content to find the number(s) or name(s) of additional pages. </p>
<p>Will be ignored, if no query is set, i.e. the value is zero.</p>
<p>If a query is set, it will overwrite <a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a12a8a7a5da10b6e8621e48730c73a870" title="Number to add to page variable for retrieving the next page, if a page number is used.">Extractor::Config::Entries::pagingStep</a>, which will no longer be used to determine the number of the next page. </p>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a539b1476f7d0f1714fa2003bbff92944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a539b1476f7d0f1714fa2003bbff92944">&#9670;&nbsp;</a></span>pagingNumberFrom</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t crawlservpp::Module::Extractor::Config::Entries::pagingNumberFrom {0}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespacecrawlservpp_1_1Query.html" title="Namespace for classes handling queries.">Query</a> to determine the total number of pages from the content of the first page. </p>
<p>Will be ignored, if no query is set, i.e. the value is zero.</p>
<p>If a query is set, it will overwrite <a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a12a8a7a5da10b6e8621e48730c73a870" title="Number to add to page variable for retrieving the next page, if a page number is used.">Extractor::Config::Entries::pagingStep</a>, and <a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a539b1476f7d0f1714fa2003bbff92944" title="Query to determine the total number of pages from the content of the first page.">Extractor::Config::Entries::pagingNumberFrom</a>, which will no longer be used to determine the number of the next page. </p>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a12a8a7a5da10b6e8621e48730c73a870"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12a8a7a5da10b6e8621e48730c73a870">&#9670;&nbsp;</a></span>pagingStep</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t crawlservpp::Module::Extractor::Config::Entries::pagingStep {1}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number to add to page variable for retrieving the next page, if a page number is used. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a1c27f27ac6c4455ef9d6fdfab9e5e3ef" title="Number of the first page.">pagingFirst</a>, <a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ae840393dfe0c185cee60a69f509b485d" title="Query on page content to find the number(s) or name(s) of additional pages.">pagingNextFrom</a>, <a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a539b1476f7d0f1714fa2003bbff92944" title="Query to determine the total number of pages from the content of the first page.">pagingNumberFrom</a>, <a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#af4a0097a5ea5e466c52a703a773f691b" title="Name of the first page.">pagingFirstString</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a8cbac30763236e922f15e280e6edcec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cbac30763236e922f15e280e6edcec1">&#9670;&nbsp;</a></span>pagingVariable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string crawlservpp::Module::Extractor::Config::Entries::pagingVariable {<a class="el" href="namespacecrawlservpp_1_1Module_1_1Extractor.html#af68631bc4caf086304cea289ce1e36ae">defaultPagingVariable</a>}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Name of the paging variable. </p>
<p>To be used in <a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a4b9f6649781af69b8af2a895b914a031" title="URL to retrieve data from.">Extractor::Config::Entries::sourceUrl</a>, <a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a6dfc4b1da76d80d3e1cb92651a96451d" title="Custom HTTP Cookie header used when retrieving data.">Extractor::Config::Entries::sourceCookies</a>, and Extractor::Config::Entries::SourceHeaders. Will be overwritten with either the number, or the name of the current page. </p>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a6dfc4b1da76d80d3e1cb92651a96451d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dfc4b1da76d80d3e1cb92651a96451d">&#9670;&nbsp;</a></span>sourceCookies</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string crawlservpp::Module::Extractor::Config::Entries::sourceCookies</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Custom HTTP <code>Cookie</code> header used when retrieving data. </p>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a2d870bc739d1a48e19efd0f76e6d5b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d870bc739d1a48e19efd0f76e6d5b3f">&#9670;&nbsp;</a></span>sourceHeaders</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; crawlservpp::Module::Extractor::Config::Entries::sourceHeaders</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Custom HTTP headers used when retrieving data. </p>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a4b9f6649781af69b8af2a895b914a031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b9f6649781af69b8af2a895b914a031">&#9670;&nbsp;</a></span>sourceUrl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string crawlservpp::Module::Extractor::Config::Entries::sourceUrl</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>URL to retrieve data from. </p>
<dl class="section note"><dt>Note</dt><dd>The URL needs to be absolute, but without protocol, e.g. <code>en.wikipedia.org/wiki/Main_Page</code>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a23e5c1309ed4550f471919078784e3ea">crawlservpp::Module::Extractor::Config::checkOptions()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="adab379e24c181fb3f796fbda4d5c4e5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adab379e24c181fb3f796fbda4d5c4e5f">&#9670;&nbsp;</a></span>sourceUrlFirst</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string crawlservpp::Module::Extractor::Config::Entries::sourceUrlFirst</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>URL of the first page to retrieve data from. </p>
<dl class="section note"><dt>Note</dt><dd>The URL needs to be absolute, but without protocol, e.g. <code>en.wikipedia.org/wiki/Main_Page</code>.</dd></dl>
<p>Will be ignored, when empty. </p>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a23e5c1309ed4550f471919078784e3ea">crawlservpp::Module::Extractor::Config::checkOptions()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="ae9d37f47f189161b56bcc838ac0f88f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9d37f47f189161b56bcc838ac0f88f5">&#9670;&nbsp;</a></span>sourceUsePost</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool crawlservpp::Module::Extractor::Config::Entries::sourceUsePost {false}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies whether to use HTTP POST instead of HTTP GET for extracting data. </p>
<dl class="section note"><dt>Note</dt><dd>When HTTP POST is used, arguments attached to the URL (e.g. <code></code>?var1&amp;var2=valueOfVar2) will be sent as arguments of the HTTP POST request instead of parts of the URL. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a87bdc42f81d342fe0ba7d398220a63ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87bdc42f81d342fe0ba7d398220a63ca">&#9670;&nbsp;</a></span>variablesAlias</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; crawlservpp::Module::Extractor::Config::Entries::variablesAlias</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for the variable with same array index. </p>
<p>Variable aliases allow additions to (and subtractions from, via negative values) the value of variables. The name of the variable alias will be replaced with the resulting value.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a537337679b5a29b1f5eee89db7a09450" title="Variable names.">variablesName</a>, <a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a9a3f1d2c72cc2bf0e585ea51c50dedaf" title="Value to add to the variable alias with the same array index.">variablesAliasAdd</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a23e5c1309ed4550f471919078784e3ea">crawlservpp::Module::Extractor::Config::checkOptions()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a9a3f1d2c72cc2bf0e585ea51c50dedaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a3f1d2c72cc2bf0e585ea51c50dedaf">&#9670;&nbsp;</a></span>variablesAliasAdd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::int64_t&gt; crawlservpp::Module::Extractor::Config::Entries::variablesAliasAdd</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Value to add to the variable alias with the same array index. </p>
<p>Use negative values to subtract from the original value.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a537337679b5a29b1f5eee89db7a09450" title="Variable names.">variablesName</a>, <a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a87bdc42f81d342fe0ba7d398220a63ca" title="Alias for the variable with same array index.">variablesAlias</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a23e5c1309ed4550f471919078784e3ea">crawlservpp::Module::Extractor::Config::checkOptions()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a496079302ceff8f225d3dd473aa83f16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a496079302ceff8f225d3dd473aa83f16">&#9670;&nbsp;</a></span>variablesDateTimeFormat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; crawlservpp::Module::Extractor::Config::Entries::variablesDateTimeFormat</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Date/time format to be used for the variable with the same array index. </p>
<p>If empty, no date/time conversion will be performed.</p>
<p>See Howard E. Hinnant's <a href="https://howardhinnant.github.io/date/date.html#from_stream_formatting">C++ <code>date.h</code> library documentation</a> for details.</p>
<p>Set a string to <code>UNIX</code> to parse Unix timestamps, i.e. seconds since the Unix epoch, instead.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>Not implemented yet.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a537337679b5a29b1f5eee89db7a09450" title="Variable names.">variablesName</a>, <a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a548bdb7e71090d88501c25ed4df6d3f4" title="Date/time locale to be used for the variable with the same array index.">variablesDateTimeLocale</a>, <a class="el" href="namespacecrawlservpp_1_1Helper_1_1DateTime.html#ab1133490ed8dd299712c6642107b15fb" title="Converts date/time with a custom format into the format YYYY-MM-DD HH:MM:SS.">Helper::DateTime::convertCustomDateTimeToSQLTimeStamp</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a23e5c1309ed4550f471919078784e3ea">crawlservpp::Module::Extractor::Config::checkOptions()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a548bdb7e71090d88501c25ed4df6d3f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a548bdb7e71090d88501c25ed4df6d3f4">&#9670;&nbsp;</a></span>variablesDateTimeLocale</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; crawlservpp::Module::Extractor::Config::Entries::variablesDateTimeLocale</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Date/time locale to be used for the variable with the same array index. </p>
<p>Will be ignored, if no corresponding date/time format is given.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>Not implemented yet.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a537337679b5a29b1f5eee89db7a09450" title="Variable names.">variablesName</a>, <a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a496079302ceff8f225d3dd473aa83f16" title="Date/time format to be used for the variable with the same array index.">variablesDateTimeFormat</a>, <a class="el" href="namespacecrawlservpp_1_1Helper_1_1DateTime.html#ab1133490ed8dd299712c6642107b15fb" title="Converts date/time with a custom format into the format YYYY-MM-DD HH:MM:SS.">Helper::DateTime::convertCustomDateTimeToSQLTimeStamp</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a23e5c1309ed4550f471919078784e3ea">crawlservpp::Module::Extractor::Config::checkOptions()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a537337679b5a29b1f5eee89db7a09450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a537337679b5a29b1f5eee89db7a09450">&#9670;&nbsp;</a></span>variablesName</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; crawlservpp::Module::Extractor::Config::Entries::variablesName</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variable names. </p>
<p>Strings to be replaced by the respective variable values in <a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a172e4f528d26d7705ad05c0bb8158528" title="Source URL for the token variable with the same array index.">Extractor::Config::Entries::variablesTokensSource</a>, Extractor::Config::variablesTokensHeaders, Extractor::Config::sourceUrl, Extractor::Config::sourceCookies, and Extractor::Config::sourceHeaders. </p>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a23e5c1309ed4550f471919078784e3ea">crawlservpp::Module::Extractor::Config::checkOptions()</a>, <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Thread.html#a8beba4474faa5bf4b0d3fed98557a3f3">crawlservpp::Module::Extractor::Thread::onInit()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a29ebf05ef3503f82773fd204b2471df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29ebf05ef3503f82773fd204b2471df5">&#9670;&nbsp;</a></span>variablesParsedColumn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; crawlservpp::Module::Extractor::Config::Entries::variablesParsedColumn</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parsed column for the value of the variable with the same array index. </p>
<dl class="section note"><dt>Note</dt><dd>Will only be used, if parsed data is the source of the variable.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ad6f4a6e514b4f8cfabd47c064333ff69" title="Source of the variable with the same array index.">variablesSource</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a23e5c1309ed4550f471919078784e3ea">crawlservpp::Module::Extractor::Config::checkOptions()</a>, <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Thread.html#a8beba4474faa5bf4b0d3fed98557a3f3">crawlservpp::Module::Extractor::Thread::onInit()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a41149ab3a45aa1310f5aeeb6c4a9bb97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41149ab3a45aa1310f5aeeb6c4a9bb97">&#9670;&nbsp;</a></span>variablesParsedTable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; crawlservpp::Module::Extractor::Config::Entries::variablesParsedTable</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Name of the table containing the parsed data for the variable with the same array index. </p>
<dl class="section note"><dt>Note</dt><dd>Will only be used, if parsed data is the source of the variable.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ad6f4a6e514b4f8cfabd47c064333ff69" title="Source of the variable with the same array index.">variablesSource</a>, <a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ab1d5e42c084c36b56f6a107edff41c6c" title="Query on the content or URL for the variable with the same array index.">variablesQuery</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a23e5c1309ed4550f471919078784e3ea">crawlservpp::Module::Extractor::Config::checkOptions()</a>, <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Thread.html#a8beba4474faa5bf4b0d3fed98557a3f3">crawlservpp::Module::Extractor::Thread::onInit()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="ab1d5e42c084c36b56f6a107edff41c6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1d5e42c084c36b56f6a107edff41c6c">&#9670;&nbsp;</a></span>variablesQuery</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::uint64_t&gt; crawlservpp::Module::Extractor::Config::Entries::variablesQuery</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespacecrawlservpp_1_1Query.html" title="Namespace for classes handling queries.">Query</a> on the content or URL for the variable with the same array index. </p>
<dl class="section note"><dt>Note</dt><dd>Will only be used, if the content or the URL is the source of the variable.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ad6f4a6e514b4f8cfabd47c064333ff69" title="Source of the variable with the same array index.">variablesSource</a>, <a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ab1d5e42c084c36b56f6a107edff41c6c" title="Query on the content or URL for the variable with the same array index.">variablesQuery</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a23e5c1309ed4550f471919078784e3ea">crawlservpp::Module::Extractor::Config::checkOptions()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="ad6f4a6e514b4f8cfabd47c064333ff69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6f4a6e514b4f8cfabd47c064333ff69">&#9670;&nbsp;</a></span>variablesSource</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::uint8_t&gt; crawlservpp::Module::Extractor::Config::Entries::variablesSource</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Source of the variable with the same array index. </p>
<p>Determines whether to use the table column stored in <a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a41149ab3a45aa1310f5aeeb6c4a9bb97" title="Name of the table containing the parsed data for the variable with the same array index.">Extractor::Config::Entries::variablesParsedTable</a> and <a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a29ebf05ef3503f82773fd204b2471df5" title="Parsed column for the value of the variable with the same array index.">Extractor::Config::Entries::variablesParsedColumn</a>, or the query stored in <a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ab1d5e42c084c36b56f6a107edff41c6c" title="Query on the content or URL for the variable with the same array index.">Extractor::Config::Entries::variablesQuery</a> to determine the value of the variable with the same array index.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacecrawlservpp_1_1Module_1_1Extractor.html#a779704b3e8359f31756ac58cc829f3e2" title="Extract variable value from parsed data.">variablesSourcesParsed</a>, <a class="el" href="namespacecrawlservpp_1_1Module_1_1Extractor.html#a2a33ed471abef4ed41731da67751cd4d" title="Extract variable value from the content of a crawled web page.">variablesSourcesContent</a>, <a class="el" href="namespacecrawlservpp_1_1Module_1_1Extractor.html#aa330dacb3998757c7d6da7faf8921d6d" title="Extract variable value from the URL of a crawled web page.">variablesSourcesUrl</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a23e5c1309ed4550f471919078784e3ea">crawlservpp::Module::Extractor::Config::checkOptions()</a>, <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Thread.html#a8beba4474faa5bf4b0d3fed98557a3f3">crawlservpp::Module::Extractor::Thread::onInit()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="ae15120e18cae30bb900cbc9c057c20d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae15120e18cae30bb900cbc9c057c20d5">&#9670;&nbsp;</a></span>variablesTokenHeaders</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; crawlservpp::Module::Extractor::Config::Entries::variablesTokenHeaders</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Custom HTTP headers to be used for ALL token variables. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a172e4f528d26d7705ad05c0bb8158528" title="Source URL for the token variable with the same array index.">variablesTokensSource</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a5c5fd3296338244f27c7e936937c842a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c5fd3296338244f27c7e936937c842a">&#9670;&nbsp;</a></span>variablesTokens</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; crawlservpp::Module::Extractor::Config::Entries::variablesTokens</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of token variables. </p>
<p>Strings to be replaced with the value of the respective token variable in <a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a4b9f6649781af69b8af2a895b914a031" title="URL to retrieve data from.">Extractor::Config::Entries::sourceUrl</a>, <a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a6dfc4b1da76d80d3e1cb92651a96451d" title="Custom HTTP Cookie header used when retrieving data.">Extractor::Config::Entries::sourceCookies</a>, and <a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a2d870bc739d1a48e19efd0f76e6d5b3f" title="Custom HTTP headers used when retrieving data.">Extractor::Config::Entries::sourceHeaders</a>.</p>
<p>The values of token variables are determined by requesting data from external soures.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a172e4f528d26d7705ad05c0bb8158528" title="Source URL for the token variable with the same array index.">variablesTokensSource</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a23e5c1309ed4550f471919078784e3ea">crawlservpp::Module::Extractor::Config::checkOptions()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a97fd461ee8800b015e255f34c17f8d19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97fd461ee8800b015e255f34c17f8d19">&#9670;&nbsp;</a></span>variablesTokensCookies</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; crawlservpp::Module::Extractor::Config::Entries::variablesTokensCookies</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Custom HTTP <code>Cookie</code> header for the token variable with the same array index. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a172e4f528d26d7705ad05c0bb8158528" title="Source URL for the token variable with the same array index.">variablesTokensSource</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a23e5c1309ed4550f471919078784e3ea">crawlservpp::Module::Extractor::Config::checkOptions()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a010c8c080034acab14341d91108d5124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a010c8c080034acab14341d91108d5124">&#9670;&nbsp;</a></span>variablesTokensQuery</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::uint64_t&gt; crawlservpp::Module::Extractor::Config::Entries::variablesTokensQuery</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespacecrawlservpp_1_1Query.html" title="Namespace for classes handling queries.">Query</a> to extract token variable with the same array index. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a172e4f528d26d7705ad05c0bb8158528" title="Source URL for the token variable with the same array index.">variablesTokensSource</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a23e5c1309ed4550f471919078784e3ea">crawlservpp::Module::Extractor::Config::checkOptions()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a172e4f528d26d7705ad05c0bb8158528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a172e4f528d26d7705ad05c0bb8158528">&#9670;&nbsp;</a></span>variablesTokensSource</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; crawlservpp::Module::Extractor::Config::Entries::variablesTokensSource</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Source URL for the token variable with the same array index. </p>
<dl class="section note"><dt>Note</dt><dd>The URL needs to be absolute, but without protocol, e.g. <code>en.wikipedia.org/wiki/Main_Page</code>.</dd></dl>
<p>To retrieve the content of the URL, the headers specified in <a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#ae15120e18cae30bb900cbc9c057c20d5" title="Custom HTTP headers to be used for ALL token variables.">Extractor::Config::Entries::variablesTokenHeaders</a>, and the cookies specified in the string with the same array index in <a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a97fd461ee8800b015e255f34c17f8d19" title="Custom HTTP Cookie header for the token variable with the same array index.">Extractor::Config::Entries::variablesTokensCookies</a> will be used.</p>
<p><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a1a1a3d9b38b668ae03781f1cb3e6b9ff" title="Specifies whether to use HTTP POST instead of GET for the token variable with the same array index.">Extractor::Config::Entries::variablesTokensUsePost</a> specifies whether to use HTTP POST, instead of HTTP GET, when retrieving the content. When HTTP POST is used, arguments attached to the URL (e.g. <code></code>?var1&amp;var2=valueOfVar2) will be sent as arguments of the HTTP POST request instead of parts of the URL.</p>
<p>Afterwards, the query with the same array index in <a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a010c8c080034acab14341d91108d5124" title="Query to extract token variable with the same array index.">Extractor::Config::Entries::variablesTokensQuery</a> will be used to determine the value of the respective token variable. </p>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a23e5c1309ed4550f471919078784e3ea">crawlservpp::Module::Extractor::Config::checkOptions()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<a id="a1a1a3d9b38b668ae03781f1cb3e6b9ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a1a3d9b38b668ae03781f1cb3e6b9ff">&#9670;&nbsp;</a></span>variablesTokensUsePost</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;bool&gt; crawlservpp::Module::Extractor::Config::Entries::variablesTokensUsePost</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies whether to use HTTP POST instead of GET for the token variable with the same array index. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html#a172e4f528d26d7705ad05c0bb8158528" title="Source URL for the token variable with the same array index.">variablesTokensSource</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a23e5c1309ed4550f471919078784e3ea">crawlservpp::Module::Extractor::Config::checkOptions()</a>, and <a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html#a70d165c478c2e7fab0f8d212dc6c416b">crawlservpp::Module::Extractor::Config::parseOption()</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>Module/Extractor/<a class="el" href="Module_2Extractor_2Config_8hpp_source.html">Config.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="anamespacecrawlservpp_1_1Module_1_1Extractor_html_aa0e6ada78b31ff4e02f856b5b63aac07"><div class="ttname"><a href="namespacecrawlservpp_1_1Module_1_1Extractor.html#aa0e6ada78b31ff4e02f856b5b63aac07">crawlservpp::Module::Extractor::defaultRetryHttpStatusCodes</a></div><div class="ttdeci">constexpr std::array defaultRetryHttpStatusCodes</div><div class="ttdoc">HTTP status codes to retry by default.</div><div class="ttdef"><b>Definition:</b> Config.hpp:86</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecrawlservpp.html">crawlservpp</a></li><li class="navelem"><a class="el" href="namespacecrawlservpp_1_1Module.html">Module</a></li><li class="navelem"><a class="el" href="namespacecrawlservpp_1_1Module_1_1Extractor.html">Extractor</a></li><li class="navelem"><a class="el" href="classcrawlservpp_1_1Module_1_1Extractor_1_1Config.html">Config</a></li><li class="navelem"><a class="el" href="structcrawlservpp_1_1Module_1_1Extractor_1_1Config_1_1Entries.html">Entries</a></li>
    <li class="footer">Generated on Fri Jul 31 2020 10:43:48 for crawlserv++ by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
